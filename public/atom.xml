<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[M疯丶]]></title>
  <subtitle><![CDATA[基础·极致·分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://emacs.cn/"/>
  <updated>2018-08-24T03:03:52.825Z</updated>
  <id>https://emacs.cn/</id>
  
  <author>
    <name><![CDATA[emacs.cn]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[]]></title>
    <link href="https://emacs.cn/2017/09/git/"/>
    <id>https://emacs.cn/2017/09/git/</id>
    <published>2017-09-20T07:15:19.000Z</published>
    <updated>2017-09-20T07:15:19.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySql InnoDB事务死锁问题]]></title>
    <link href="https://emacs.cn/2017/08/mysql-transaction-deadlock/"/>
    <id>https://emacs.cn/2017/08/mysql-transaction-deadlock/</id>
    <published>2017-08-05T15:30:36.000Z</published>
    <updated>2018-08-24T03:03:43.612Z</updated>
    <content type="html"><![CDATA[<p>这篇博客的文章内容发生于某天晚上服务端日志报了一大堆 Deadlock found when trying to get lock; try restarting transaction，当时通过字面意思果断可以判断出是Sql事务死锁了，与此同时，MySql所在服务器CPU也远超100%，第一直觉是事务死锁导致线程阻塞，请求数瞬间过多导致CPU超100%。<br><img style="float:right" src="https://img.emacs.cn/20180824110118.jpg" width="50%" height="50%"><br>什么情况下会导致死锁呢？根据以往经验，应该是同时操作了（update/delete等）同一条数据库的记录导致了事务阻塞，由于事务的执行时间过长导致了其他事务的等待，导致CPU攀高。</p>
<p>死锁这个问题基本上可以说涉及了InnoDB大部分特性：行锁设计，非锁定读，事务，MVCC，聚簇索引 等等，有必要写篇文章好好分析下。</p>
<a id="more"></a>
<p>若要全方面解决InnoDB死锁问题，我们需要对下面几个方面了如指掌。</p>
<ul>
<li>MVCC</li>
<li>事务的隔离级别</li>
<li>快照读和当前读</li>
<li>聚簇索引</li>
<li>死锁</li>
<li>INNODB_TRX，INNODB_LOCKS，INNODB_LOCK_WAITS </li>
</ul>
<t>MVCC</t>

<p>多版本并发控制是指InnoDB存储引擎通过行多版本的方式来读取当前执行时间数据库中的行数据，简单说就是读不加锁，读写不冲突。这样会极大的增加数据库的并发性能。有人问了，读不加锁，那么写会加锁的啊，这个时候再同时进行读能正常读取吗，答案是肯定的，读取操作不会因为锁没释放而等待，而是会去读取行的一个快照数据（不同事务的隔离级别，访问的快照数据不同）。</p>
<t>事务的隔离级别</t>

<ul>
<li>Read Uncommited</li>
<li>Read Çommited</li>
<li>Repeatable Read</li>
<li>Serializable</li>
</ul>
<p>其中，Read Uncommited 和 Serializable 比较极端，前一个可以读取未提交的记录，后一个读写冲突，并发性低，所以两者在一般情况下都不建议使用，用的最多是RC和RR。</p>
<p>RC级别有关键词：最新数据<br>RR级别的关键词：最初数据</p>
<p>我们来看具体的例子，我们模拟两个并发事务请求，分别是：<br>Connection A:</p>
<pre>
<code class="sql">start TRANSACTION; 
select * from tDeadLock where id = 1;
</code>
</pre>

<p>Connection B:</p>
<pre>
<code class="sql">start TRANSACTION; 
update tDeadLock set count=count+1 where id = 1;
</code>
</pre>

<p>在说这两个请求之前，我们先看tDeadLock这个测试表的结构</p>
<table>
<thead>
<tr>
<th style="text-align:center">id (Primary Key 下同)</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p></p><p><br>我们再回头看两个Connection，A事务中已经开始事务，读取了id=1的数据，但是没有结束事务，同时B中进行并发访问，将id=1的count加1,两者事务都没有提交，因为进行了update，id=1的加了一个x锁，在A连接进行读取的过程中，RC和RR事务的隔离级别下，会使用非锁定一致性读。当A事务未关闭，B事务进行commit后，在RC和RR情况下A事务显示的结果就不一样了。</p>
<h4 id="1、RC">1、RC</h4>
<p>在当前两个连接开始之前先执行下面两句，强制使用RC事务隔离级别。</p>
<pre>
<code class="sql">SET @@global.tx_isolation = 'READ-COMMITTED'; 
SET SESSION tx_isolation = 'READ-COMMITTED';
</code>
</pre>

<p>可以使用下面命令验证是否修改成功。</p>
<pre>
<code class="sql">SELECT @@global.tx_isolation;
SELECT @@tx_isolation;
</code>
</pre>

<p>RC事务隔离级别的关键词是： 最新数据，所以当B事务进行了commit，在A事务中进行查询会显示count的值为2。</p>
<h4 id="2、RR">2、RR</h4>
<p>同理我们强制使用RR事务隔离级别。</p>
<pre>
<code class="sql">SET @@global.tx_isolation = 'REPEATABLE-READ'; 
SET SESSION tx_isolation = 'REPEATABLE-READ'; 
</code>
</pre>

<p>RR事务隔离级别的关键词是：最初数据，所以当B事务进行了commit，在A事务中进行查询的会显示count依然为1。</p>
<t>快照读和当前读</t>

<p>可以这么认为除select外是快照读（select for update，select lock in share mode特殊除外），其他都可以认为是当前读。读取的是记录的最新版本数据，为了保证并发的时候读取的是最新数据需要对改记录进行X锁。</p>
<p>我们来看下例子，在之前的tDeadLock表增加一条记录</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h4 id="RR事务隔离级别">RR事务隔离级别</h4>
<p>我们来看具体的例子，我们模拟两个并发请求，分别是：<br>Connection A:</p>
<pre>
<code class="sql">start TRANSACTION; 
select * from tDeadLock;
</code>
</pre>

<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p></p><p><br>Connection B:</p>
<pre>
<code class="sql">update tDeadLock set count=count+1 where id = 1;
</code>
</pre>

<p>在事务A中继续执行</p>
<pre>
<code class="sql">select * from tDeadLock for update;
</code>
</pre>

<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><font color="red">2</font></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p></p><p><br>当前读，查询到的是获取更新过后的数据，我们再在事务A中运行</p>
<pre>
<code class="sql">select * from tDeadLock;
</code>
</pre>

<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p></p><p><br>快照读，获取的是当前事务之前的快照。可以看出不同的事务隔离级别下，快照读和当前读获取的数据是不一样的。（因为RC获取最新数据，RR是获取最初数据，两个概念一结合就比较好理解了。）</p>
<t>死锁</t>

<p>文章开头解释了为什么会导致CPU 100%，但是就算100%，并发访问量比较大，也只是处理会变慢而已，为什么会产生死锁呢？ </p>
<p>唯一的可能是多个进程在互相竞争资源，互相对方需要的资源不释放，导致死锁，我们还是回头来看那个例子。</p>
<p>Connection A:</p>
<pre>
<code class="sql">start TRANSACTION; 
select * from tDeadLock where id = 1 for update;
</code>
</pre>

<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>


</p><p>Connection B:</p>
<pre>
<code class="sql">start TRANSACTION; 
select * from tDeadLock where id = 2 for update;
</code>
</pre>

<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>

</p><p>这两个事务都在所查询的记录上加了X锁，如果事务A继续执行下面这句Sql，会出现阻塞状态。</p>
<pre>
<code class="sql">select * from tDeadLock where id = 2 for update;
</code>
</pre>

<p>这个时候事务B继续执行事务A加锁的id=1这条记录。就会出现死锁状态，事务A和事务B明显的在竞争资源。当发生死锁的时候，事务B会进行回滚，这个时候事务又可以继续执行完成。</p>
<t>INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS</t>

<p>这个时候，我们再来看和锁相关的表：</p>
<h4 id="INNODB_TRX">INNODB_TRX</h4>
<blockquote>
<p>事务表，正在运行的事务都会显示</p>
</blockquote>
<ul>
<li>trx_id 事务id</li>
<li>trx_state 事务状态</li>
<li>trx_requested_lock_id 等待事务锁id</li>
<li>trx_weight 事务权重</li>
<li>trx_mysql_thread_id mysql中的线程id</li>
<li>trx_query 事务运行的sql语句<p>

</p></li>
</ul>
<h4 id="INNODB_LOCKS">INNODB_LOCKS</h4>
<blockquote>
<p>锁表</p>
</blockquote>
<ul>
<li>lock_index 锁的索引</li>
<li>lock_space INNODB存储引擎表空间的ID号</li>
<li>lock_page 被锁住的页数量</li>
<li>lock_rec 被锁住的行数量</li>
<li>lock_data 被锁住的行主键值<p>

</p></li>
</ul>
<h4 id="INNODB_LOCK_WAITS">INNODB_LOCK_WAITS</h4>
<blockquote>
<p>锁等待表</p>
</blockquote>
<ul>
<li>requesting_trx_id 申请锁事务ID</li>
<li>request_lock_id 申请的锁</li>
<li>blocking_trx_id  阻塞事务ID</li>
<li>blocking_lock_id 阻塞锁的ID<p>

</p></li>
</ul>
<p>其中 trx_mysql_thread_id 这个id，如果特殊情况，可以根据show full processlist命令查询出来进程id来kill掉，具体表的使用可以参考之前的例子来看下各个表的数据。</p>
<p>

</p><p><t>总结</t><br>当了解死锁背后一些原理后，处理起死锁问题就有迹可循了。</p>
<ul>
<li>写程序的时候可以尽量避免事务的过长（处理时间）</li>
<li>写事务的时候避免相互竞争资源的情况</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇博客的文章内容发生于某天晚上服务端日志报了一大堆 Deadlock found when trying to get lock; try restarting transaction，当时通过字面意思果断可以判断出是Sql事务死锁了，与此同时，MySql所在服务器CPU也远超100%，第一直觉是事务死锁导致线程阻塞，请求数瞬间过多导致CPU超100%。<br><img style="float:right" src="https://img.emacs.cn/20180824110118.jpg" width="50%" height="50%"><br>什么情况下会导致死锁呢？根据以往经验，应该是同时操作了（update/delete等）同一条数据库的记录导致了事务阻塞，由于事务的执行时间过长导致了其他事务的等待，导致CPU攀高。</p>
<p>死锁这个问题基本上可以说涉及了InnoDB大部分特性：行锁设计，非锁定读，事务，MVCC，聚簇索引 等等，有必要写篇文章好好分析下。</p>
]]>
    
    </summary>
    
      <category term="Mysql" scheme="https://emacs.cn/tags/Mysql/"/>
    
      <category term="InnoDB" scheme="https://emacs.cn/tags/InnoDB/"/>
    
      <category term="死锁" scheme="https://emacs.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「九」：2015，这一年]]></title>
    <link href="https://emacs.cn/2016/02/startup-9-2015-this-year/"/>
    <id>https://emacs.cn/2016/02/startup-9-2015-this-year/</id>
    <published>2016-02-03T13:30:00.000Z</published>
    <updated>2017-07-27T11:08:28.000Z</updated>
    <content type="html"><![CDATA[<p>2015年4月5日一口气读完《创业时，我们在知乎聊什么》，其中一段话是这样的：</p>
<p>“脸谱网很受早期用户欢迎，但他并不知道这个事情有多么重要。他到硅谷后还一度说脸谱网这个项目并不重要，想靠脸谱网吸引一些用户来，真正想干的事是做一个下载软件。后来是肖恩·帕克(Sean Parker)告诉马克别去干其他东西，干这个就对了。</p>
<p>校内网当年在清华大学电子系学生节晚会前后几天之间，吸引了四五千名实名注册的用户，但是学生节晚会之后又不怎么增长了。在这之后我们也出现过摇摆，在想是不是要干另外一个项目。</p>
<p>老外有一种说法，很多人在很多时刻都会被一个真理绊倒，但多数人都会爬起来继续摸索。你被一个正确的机会绊倒过，但是你不知道那是机会而继续摸索，其实这时候你已经错过了这个机会。”</p>
<p>当时读完这文字后我是这么写下读后感的：</p>
<blockquote>
<p>“深有感触，这让我又想到初心二字，初心也许在你看过很多鸡汤文后是个非常反感的词，但是我一直觉得初心是个审视自己及出发点的用词，到底是去做另外个项目还是坚持现在的。这和你最初的出发点是息息相关的，就像”ONE一个”说的：永远不要为了目的而忘了初衷。就像给风的命名，不是它要去的方向。”。</p>
</blockquote>
<a id="more"></a>
<p><strong> <center>“碰撞” 投资人</center> </strong></p>
<p>2015年3月25日，因为24pi产品，第一次和创投的朋友交流，那是晚上十一点左右，我和投资人在电话里”争吵”了近1刻钟，她言辞犀利的向我“质问”了两个问题：「工具vs社区，效率vs沉淀时间」。我沉默了，可以说直接命中我痛点，她让我再沉淀一阵子，下次见面方能”吵”的更激烈。言外之意是，我对我们的产品没想清楚，坦率说，这也是很长一段时间我们团队一直在思考，但确实没想清楚的事情。</p>
<p>短短的20分钟，和投资人接触后，让我了解到产品的问题所在。也是让我第一次发现和投资人”争吵”的益处。</p>
<p>第二次和投资人面对面碰撞，是在中国创新创业大赛，我们公司代表上海赛区进总决赛的时候，当时上海有个模拟演示的机会，是投资人当评委对你现场限时7分钟的产品演说，进行针对性的提问，当时老褚自己也挺忙，二来也没当回事，就让Summer去下，Summer收到消息后，有点不知所措，把PPT看了一遍又一遍，还是有点胆战心惊……我把PPT在电脑中打开，陪着她演说着，之后还是一脸求助的眼神望着我，我就安抚说：”他，这么做肯定为你好，就当给你一次历练”，当时Summer不急不慢的说了一句：”可是，每个人是有分工的啊，有的事情我的确做不了，我只能做些公司的幕后事情，那些是我擅长的。”，我沉默了下，暗暗赞同，说，那我去吧。</p>
<p>那天早早的和Summer约好在上海南站，一起去科创园，早上抽签抽到是下午，中间隔了一段时间，顺便去医院做了下马拉松体检，中午和Summer在上海南站下面找了个地方点了几个小菜 小喝了点啤酒，和Summer说：”也许老的时候你会记起这些拼搏的日子，而真正那些你每天都在做的’任务’往往并不会想起。”  这就是我选择这条创业路的原因，Summer似懂非懂，抿着嘴，微笑的看着我。</p>
<p>快轮到我们公司演说的时候，我整理了下思路，在7分钟不到的时候就把30多张PPT上重点都提了一遍，说完，我看了下台下的四个评委（投资人），他们看了下我，说，能不能把你们的盈利模式再说下，我知道讲的有点快了，之后又进行了8分钟的答问，投资人问的一些问题的确尖锐，在8分钟有限的时间内，如果你对自己的产品不是特别清楚，你会被抓住很多细节把柄，要知道投资人已经看过太多个项目了，他们投资主要看团队，产品，技术，商业模式，如果你没技术壁垒只能跟别人拼商业模式，当然团队牛逼也会加分。 </p>
<p>总之，多和投资人“争吵”是利大于弊的，他们看的角度你平常不一定能想到，你认为比较牛逼的商业模式，说不定是闭门造车，可以达到一针见血的效果。</p>
<p><strong> <center>招募合适的人才</center> </strong></p>
<p>招聘已经成为每家企业的最头疼的地方了吧，朋友圈不管是哪个朋友公司什么喜事，还是公司融了A、B、C、D轮，转文章的同时也不会忘了，加上“求人才”，“招各种大牛”，“入职的人直接配MacBook”，言语中，不管多有钱，公司想扩大必须吸收更多牛逼血液，但是招人哪有这么容易，  3月28日，原大众点评的负责人创业几年，公司发展不错，但是人才流失也特别严重，让我帮忙找个PHPer，他当时是这么和我说的：<br>“最近找人找得相当疲惫，跟谈对象类似，总是没办法找到合适的。 遇到一个好市场，公司业务往前跑不等人，基本上每天早上起来发愁的就是这件事。 不是没有简历，从薪水来讲我们还是能吸引一些简历，但是没有合适的。难道是我要求高？其实我这边就看候选人两点，一是工作态度，二是学习能力和求知欲（成长潜力）。可惜面试了好多，浑浑噩噩过日子的居多，就是公司再缺人，也不会降低要求发OFFER。 ”</p>
<p>我另外一个朋友也是，自己创业做金融终端，虽然也是技术出身，一个人可以挑起一部分，但是毕竟精力有限，四处招不到合适的人，我年中去探望过一次，小小的办公室就他一个人，他说，过两天会来一个女生和一个男生，都还不错。我问了他怎么招到的，他说都是以前公司的同事，以前公司不行了，出来创业顺便把他们也带出来了。就这样总共三个，过了大半年总共4个人，期间朋友介绍了1个人。</p>
<p>说了两个真实的例子，不是说招聘有多难，而是招到合适的人有多难，招募合适的成员就像谈恋爱一样，那种感觉真是无法形容。</p>
<p>如果单从要求来严格面试者，那么基本上很难招到一个满足的，所以我们对招聘做了一些感性的折衷，如果基础还不错，做事态度还可以，那么就试行快进快出的方式，数下来，总共辞退了4个。不过还不够快。但是这种方式是值得推崇的。</p>
<p>相比招聘渠道过来的，通过现有成员的推荐和熟人的推荐要靠谱很多。大部分人都知道，谷歌当初成立之初及之后的多年时间里，最优质的应聘者源自现有员工的推荐。曾经一度，谷歌聘用的人当中有超过半数都是其他员工推荐的。当然这也不是免费推荐，只要成功推荐的，会有2000美元-4000美元的奖励。所以这个也会鼓动员工去努力留意身边的人才。</p>
<p>从面试者自身来看，这一年面试过的人不下几百人，有几次去江南大学、火星时代、达内一天面试几十人，撇开招聘会不说，从拉勾网或智联上的面试者来看，10个有9个是海投的，有很多都是有工作经验的，就拿最近的一位面试者来说，他说：“自己现在 在公司还可以，老板对他也不错，也不急着跳槽，他就是每周随便投两个简历看看”。 听完，造成企业招聘困难的问题也不见得奇怪了，一则，大部分非常优秀的人才很少通过招聘渠道的，二则，浑水摸鱼的人实在是多，从而导致创业的人面试多了就乏力了。</p>
<p><strong> <center>产生更多工作势能</center> </strong></p>
<p>话说回来，别人那么优秀为什么要去你们公司呢，凭什么让员工像你们一样不要命的去工作呢？其实这么想本来就不对，因为你刚开始招来的时候，他就是来应聘这个工作的，他就是以员工的身份加入这个公司的，凭什么要为公司拼命呢，他如果表现的好，你应该感到幸运，他如果按时上下班你应该感到这是个正常现象。</p>
<p>如果你也是这么个想法，请你应该要好好反思下，每个人都是有私心的，只是重和轻之分，人人都知道付出和回报要起码是个正比。</p>
<p>那么怎么能够让员工无所顾忌、尽其权利地参与企业的成长？可以想下，作为创始人的你如何和你现在的联合创始人一起协同工作这么多年的，除了价值观相同外，还有一种是合伙，共享公司成与败。</p>
<p>其实这个就是种意识上的平等，要让员工真心感受到，在这个公司会有出头之日，另外整个组织也要有心胸敢用人，给足每个人机会，让每个人都有机会做顶梁柱。</p>
<p>所以必须创造一种机制，把员工变成合作伙伴，尊重并给予员工机会，包括共享企业成功的机会。</p>
<p><strong> <center>谈谈合伙制</center> </strong></p>
<p>1、第一次合伙是大学三年级的时候，我拿30%的技术股，当然我主要负责整个技术，他来负责整个业务，这种合作模式其实非常好，互不介入对方负责区域，各自负责一块，具体产品这块之后会提到。<br>2、第二次是不谈。<br>3、第三次是我创立夺研的时候，我和立平两个人，开始我占60%股，他占40%，后来股份又做了次调整，还是我负责技术和产品，他来负责市场，虽然现在暂时划上句号，但是两个人合作非常不错，上次电话还聊了近1个多小时，说：“其实两个人如果非常互补的话，基本上不需要太多废话的。”，嗯，不过前提是两人价值观要一样。当然价值观不一样就不可能走到一起。其实，在认识立平之前，是先认识的周秦同学，因为她的笔记，我突发奇想创立了笔记网这个网站，可以说，虽然笔记不多，流量不大，但是现金流还是可以的。但是这个模式有很大问题。以后再谈。<br>4、现在这次是近两年的合伙创业，我还是以技术名义加入，目前这种模式，有利有弊，利的是有互补的，弊的是互补性不够强。</p>
<p>以上是我创业以来，几次合伙制简短介绍，下面就从现实角度谈下合伙。首先任何一家公司的创立只有一个创始人，多个联合创始人，一家公司的创立更多的是商业的需要，而真正内在的是他的核心产品，真正倡导做这个产品的是这个创始人，其他联合创始人可能是在听完这个创始人的话后，价值观相同后，才撸起膀子一起做一件事的，任何一个产品的核心价值观只有他的创始人最清楚。所以很多时候不管是创业路演还是见投资人，必须是创始人去。其他人是代替不了的，角度是不一样的。</p>
<p>另外，如果确信这几个人是要一起创业，那么大家一起投钱，要么就别扯，利益的捆绑是最牢靠的，人情的维系最靠不住的。千万不能为了吸引人才以干股的形式赠予核心人员，很简单的道理，所谓干股就是“利益共享，不承担风险”，一旦遇到风险，就呵呵了。</p>
<p>创业团队要不要拿工资？可以，但是根据实际情况，原则是，低工资，高分红，且，恩，还有一件很重要的事，就是：这种分配必须透明化。</p>
<p><strong> <center>“创业” 和”项目”的难舍难分</center> </strong></p>
<p>我所遇到的大部分初创企业 直接做产品的比较多，整个公司围着一个产品转，简单来说就是all in，但是也有不少企业，开始接的是外包项目，因为企业首先要生存，有什么项目就接什么，在这个”痛苦做项目”的过程中寻找公司的突破点，也就是在众多项目中寻找一个“idea”进行产品式的突破。还有一些公司，因为业务拓展需要必须要做这个领域的项目，才能打开市场口子。</p>
<p>但是做项目和做产品不同，项目对应着客户，产品对应着用户，恰恰是这两者的不同，导致做起来愉悦性完全不一样。没有愉悦感就很难有持续性。而且客户的需求变更特别频繁，有的客户没想法还好，公司可以主导一下，就怕客户有想法，但是又没主见，做出来的效果经常被ban掉，所以后来就学乖了，先把项目MVP化，然后实现基本的线稿图或低保真，再做基本交互（能最快的动画实现细节交互更好）客户确认好后再进行开发。这个流程也是被市场验证多次是可行的，虽然很多人知道这么做，就是没去这么做。认为整个流程太繁琐，费时间，殊不知与客户的沟通成本要比这大的多。</p>
<blockquote>
<p>本土化的分布式协处理项目进度</p>
</blockquote>
<p>前面说了，因为多种原因一个公司做很多项目很正常，但是多个项目协调就会成为公司的头疼之处，或者说效率低之处，我和JJ住在一块，他是一个上市公司数据部的总负责人，所有的数据都是从他这边走，虽然平时两人都很忙， 但是基本上每周都会撞一起吃个饭，聊聊工作、创业、金融、技术、跑步等等，有一天晚上他和我说，当所负责的团队越大，自己的精力就越分散，做的事越杂且效率也不高，比方说，有很多部门都需要数据报告，那么这个数据报告就要从JJ这个部门获得，既然JJ是负责人，那么其他部门都会找他要数据，他就会变成下面这张图的样子:<br><img src="http://ww1.sinaimg.cn/large/744e593bgw1f0gbyayi8mj20fb0993yx.jpg" alt="集中化管理"></p>
<p>自己的整个时间陷入到对接部门和开发的工作中，他也摇摇头说，没办法，其实这个不仅仅是他一个人是这样，大部分企业都会有这种现象，这种现象有很多问题，比如说，在中国，技术比较牛逼的人为什么一定要做管理，为什么不做管理就不能提升呢，这是他最擅长的地方，再比方说，这种集中式管理方式为什么仍然存在，没人反思。</p>
<p>我们做项目也遇到了这种类似情况，我是一个喜欢思考，尝试新鲜的人，大部分时候想到了就去尝试了，至于结果对错，但是至少比没有尝试会好。所以当有段时间我需要抽出时间和N个客户进行协调项目的时候，我也被陷入进去了，以至于产品和项目我都没处理好，我一直在思考有没有更好的方式，有一次，我想到了计算机的组成结构，想到了分布式系统。所以我想管理是不是也可以尝试用分布式化进行管理再进行协处理器模式，我从中央处理器退居到协处理器，设计师来对接各个项目(设计驱动型)，出现问题协处理器来协调。这样有很多好处，一方面是把集中化转换成分布式的，每个设计师只要负责1-2项目，而以前可能一个人自己就要对接很多个项目；另一方面协处理器可以有更多时间处理其他更重要的事情。但是这个推动也会有阻力，设计师是否有这个能力，没有，那么就要培养。当然沟通能力也会是我们招聘设计师的要求之一。</p>
<p><strong> <center>产品思维</center> </strong></p>
<p>“人人都是产品经理”，这里不是说的每个人都可以做产品经理，而是每个人都应该拥有产品的思维，做产品就像和用户“谈恋爱”，你要先解决用户的需求，继而增加用户的体验。所以不管是公司的产品，还是外面的项目我都要求成员以产品式的思维来做事情，不管你是程序员还是设计师，你做的每一个像素还是写的每一行代码，本质都是为用户来服务的，当你要开始做一个任务的时候，实现一个功能的时候，你应该去想这个功能到底应不应该做，会不会影响到用户的使用，因为产品经理整理的需求不一定是对的，可能只是他的一次假想，没有任何数据推测。所以必须提出来，就算提的有错，也是会提高大家的产品意识的。</p>
<p>同样，从宏观的看，可以把公司的各种制度，流程都可以理解为一个产品，互相之间是独立的，一个项目都是单一的个体。要做的就是立体思考，不断创新，不同的项目上采取不同的方法，不断满足用户的需求，这才是产品思维。</p>
<p><strong> <center>公司的品牌，成员的名字</center> </strong></p>
<p>姚sir有一件事我非常赞同，也是他在10几年后引以为豪的事情：当初他在WG公司还在初创阶段的时候，当时WG公司在开始阶段也是给一些公司做项目，这本是一个很普通的事，姚sir当时是在他做的每一款券商软件中强烈要求加入公司的logo，这其实也是很普通的操作，但是仅仅这么简单的操作，却把公司品牌打出去了，初期公司主要针对B端，而企业用户只有用完了我们为B端用户做的产品，如果觉得好，才会向外推荐，让所服务的B用户喜欢上这个产品后能够了解到是我们公司做的。口碑传播的力量是非常强大的，会大大减小额外的销售成本。</p>
<p>还有一件事，是我要求做的，那就是任何一款我们所开发的软件上，署上所有参与成员的名字，成员的参与感对成员来说是非常重要的，要让大家知道，他们写的每一行代码，设计的每一个像素都是他们自己的，这是他们的作品。</p>
<p><strong> <center>真诚</center> </strong></p>
<p>我相信这两个字也不是一两句能说出他的味道的，但是这两个字确是我15年最大的收获，是老褚对这两个字的实际行动让我看到这两个字的平凡和伟大。</p>
<p><strong> <center>一个插曲</center> </strong></p>
<p>老褚闷了一口烟，看着我、叫兽还有老马说，这次竞标你觉得价格定多少，老褚之所以这么问，是因为去年被这次同样参与竞标的A上市公司给搞惨了，明明的15W，就只报了5W，价格分压的太低，也就是差不多亏本在做，这次又交手了，所以这次老褚对报价特别敏感。我低头沉思了下，预算30W，至少得高于18W，因为也是从头参与到尾的一个竞标，对整个过程和结果还是非常自信的，这时，叫兽举着右手扬了一句：上市公司肯定不会对每件事做那么充分的，我们肯定做的比他好，老褚头往右边一扭，皱着眉头说，“任何时候都不能小瞧竞争对手，要知道历史上多少战役是轻视对手战败的。”，我听了老褚这句话，又陷入了沉思，是啊，这个项目团队付出了很多努力，而且这次项目对我们公司整体布局起着非常重要的作用，得一定要拿下才是。四人看起来暂时还没拿定主意。</p>
<p>已经是晚上11点左右，我先从会议室推开门走到自己座位坐下，这次标书中的演示分有30分，得先全部拿下才是，于是操起Xcode根据要求继续做起了Demo，不断和罗丹交流着，如何设计才能完美。</p>
<p>从打印店打印标书出来已经凌晨3点，打车回家，赶明天8点得飞机的话 得5点起床才是，估计睡不了1个小时了，我这时还是比较累的，非常想休息下，打的把老褚送到公司后，自己到家，冲了个凉，定了个5:00的闹钟就开始睡了。</p>
<p>我迷迷糊糊的睡到闹钟响起，看了下闹钟，又把闹钟延时了10分钟，眯了下，想想不对，还要去公司接老褚，算了下去机场的未知时间，还是得现在就爬起来。</p>
<p>上车后，我给老褚打了个电话:”喂，我大概20分钟到”， “多少时间到？”， “20分钟”， “好，好”。我听着老褚疲倦的声音，心里也不是一番滋味，车快到公司的时候，老褚拧着标书袋快步走进车里，抱着包，随即又开始呼呼大睡了，这时丽丽发来一条微信：“你们在去机场的路上了吗？”，丽丽也是一个幕后选手，不仅心细，所有事安排的非常妥当，公司就是每个人的互相扶持，才会让公司越走越远。</p>
<p><img src="http://i4.tietuku.com/9d241e9a061af861.jpg" alt=""></p>
<p>经常能感受到:”自己的精力真的比别人多好几倍”，在公司每天忙到地铁快没时才回去，然后经常凌晨1、2点才睡觉，早上7点多起来晨跑，如果叫兽在身边，这时会来几句：“人得精力都是有限的…..” , 这句话现在在车里回荡了起来，想了想，还是闭目养神了下。</p>
<p>到了机场后，速度取完票，离起飞还有段时间，老褚像往常一样从包侧边取出杯子泡了杯茶，然后去吸烟室一个人抽烟去了，老褚虽然喜欢吸烟喝酒，但是我想这也是排解压力的一种方式吧，大多数时候老褚在会议室会一边对着电脑，一边总是在抽着烟，眉头也紧锁着。虽然我从来不吸烟但是特别能理解老褚的感受。</p>
<p>飞机落地后，我们就直奔竞标地点，进了招标室，已经来了一家竞争对手，那边负责人对我们说，9点开始，大家先把密封的标书交上来，熟悉了下环境后，渐渐来了4家竞标对手，9点开始了，一个招标公司的小姑娘在台上把竞标规则读了下，下面开始拆标书，报各家的竞标价，在上海的心里不安的叫兽在微信群里面开始问我结果怎么样了。</p>
<p>进入演示环节的时候，我本来认为Demo做的这么完美，可以让评委有好感些，没料到评委一脸不屑，冷冷的说，你们只有5分钟演示时间，请根据招标书上的规则，演示相应内容。</p>
<p>大约1分钟左右演示完，为了给几个评委留下好更好的印象，老褚还有点不甘的坐在会议桌另一旁，面对着几个评委说，请各位老师再给我1分钟时间，我们想借这次机会做一个行业内的标杆…..，演示完后让我们在隔壁的小房间等着，老褚走到走廊的一端在望着窗户外面点了根烟，等所有竞标公司竞标完后，才开始进入标书的评判阶段，开始以为很快出结果，大家都想等结果出来后再出去补充下肚子，过了下午1点，还没出结果，其他竞标公司也陆陆续续开始离开了，而我们当天晚上7点左右的飞机回上海，中午计划是要再去拜访一个朋友的，时间也比较赶，现在已经下午2点左右了，也不继续等了，下了楼梯，招了辆出租车，车大概行驶了10分钟左右，接到一个电话，对方说，我们公司中标了……</p>
<p>我和老褚同时舒了口气。</p>
<blockquote>
<p>如果这只是这一年的一个插曲，那么可以说还有很多很多，虽然不至于每天提心吊胆的活着，但是每天都在这么忙碌着，比如上面这个经历就会重复多次，有成功、也会有失败，不知道你的付出结果到底是如何；也有时候你会坐在位置上专注的敲一天的代码，你会好几天会在不同项目中进行协调着，你会为一个项目东奔西走，也会为团队……太多太多。</p>
</blockquote>
<p><strong> <center>那一瞬间</center> </strong></p>
<p>有句话说“陪伴是最长情的告白”， 对于公司，Summer在职时间是最久的，不需要任何语言修饰，就已经是最让人感动的，公司的起起伏伏，从未离开。</p>
<p>老褚每次说到天一都说，让我特别深刻，那是一个周日，公司里也没什么人，老褚那天正好去公司取个东西，推开的时候，发现天一正在专注的敲着代码。而天一给我最深刻的是：天一因为各方面原因曾经和我提出过好几次离职，有自身原因，有公司原因，最后一次提出的时候，我和他在东北饺子馆把所有问题，一一排解，现在他坚持下来了，很欣慰。</p>
<p>罗丹同学，身体长时间不适，知道公司需要设计，有段时间，腿不是特别舒服，而罗丹在问我能不能提供个环境让我趴着用做图，我说咋了，她说腿不是特别舒服，因为公司项目比较多，UI暂时就超超一个人忙不过来，我不能请假，希望可以趴着用电脑，这样会好受些…… 还有一次，12月20号的晚上，因为项目比较急，急需要一张图，凌晨，她从被窝里出来做图…… 说实话，非常感动，也希望你身体尽快康复。</p>
<p>当公司最需要iOS人员的时候，是小军你顶上去了，半年的时间，iOS也磨练的能独当一面了。 做事很安静，效率很高，最开心的时候，就是你对着天一说，”这个效果我已经实现啦，真是机智如我”。</p>
<p>来的时间不长的超超，每天事情比常人多很多，可是从没抱怨，做事也非常仔细认真。叫兽说，他最喜欢超超就是，每次布置任务，超超就说两个字，”好的”。是的，的确这样。这其实就是老褚谈论的“傻”，成功肯定会照顾这种人的。</p>
<p>太多太多感动瞬间，就先不一一罗列了。</p>
<p><strong> <center>最后想和公司团队中每一个成员说</center> </strong></p>
<p>你们坚持到现在，都是很棒的，你们每一个人都可以通过自身努力选择加入一家伟大的公司，但是要知道普通人一生中很少有机会参与打造一家伟大的公司过程中去，我们每一个人应该要用自己的努力珍惜这份幸运。</p>
<div align="right"><br><strong> 篇尾 </strong><br><br>未来不迎，当时不杂，过往不恋<br><br>2016，只能更努力<br><br></div>


]]></content>
    <summary type="html">
    <![CDATA[<p>2015年4月5日一口气读完《创业时，我们在知乎聊什么》，其中一段话是这样的：</p>
<p>“脸谱网很受早期用户欢迎，但他并不知道这个事情有多么重要。他到硅谷后还一度说脸谱网这个项目并不重要，想靠脸谱网吸引一些用户来，真正想干的事是做一个下载软件。后来是肖恩·帕克(Sean Parker)告诉马克别去干其他东西，干这个就对了。</p>
<p>校内网当年在清华大学电子系学生节晚会前后几天之间，吸引了四五千名实名注册的用户，但是学生节晚会之后又不怎么增长了。在这之后我们也出现过摇摆，在想是不是要干另外一个项目。</p>
<p>老外有一种说法，很多人在很多时刻都会被一个真理绊倒，但多数人都会爬起来继续摸索。你被一个正确的机会绊倒过，但是你不知道那是机会而继续摸索，其实这时候你已经错过了这个机会。”</p>
<p>当时读完这文字后我是这么写下读后感的：</p>
<blockquote>
<p>“深有感触，这让我又想到初心二字，初心也许在你看过很多鸡汤文后是个非常反感的词，但是我一直觉得初心是个审视自己及出发点的用词，到底是去做另外个项目还是坚持现在的。这和你最初的出发点是息息相关的，就像”ONE一个”说的：永远不要为了目的而忘了初衷。就像给风的命名，不是它要去的方向。”。</p>
</blockquote>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「八」：每个人都应该读读「重新定义团队：谷歌如何工作」]]></title>
    <link href="https://emacs.cn/2016/01/startup-8-everyone-should-read-insights-from-inside-google/"/>
    <id>https://emacs.cn/2016/01/startup-8-everyone-should-read-insights-from-inside-google/</id>
    <published>2016-01-23T15:50:33.000Z</published>
    <updated>2017-07-27T11:08:24.000Z</updated>
    <content type="html"><![CDATA[<p>这本书看似是给公司的团队leader看的，其实内容对于每一位工作的人都是受益的，我想这本书标题应该改为《重新定义自己在工作中的角色》 更为合适。</p>
<p>下面一些对我感触比较深的摘要，希望也能触动正在读本文的你，哪怕是一句。</p>
<blockquote>
<p>我们只需要坚信员工都是好的，再就是要有足够的勇气，把员工看成是企业主人翁，而不是把他们当成机器。机器会完成工作；主人翁会竭尽所能帮助企业和团队获得成功。</p>
</blockquote>
<p>人的一生大部分时间都在工作，但是对多数人而言，工作是一件痛苦的事情，只是一个谋生手段，其实不必如此。</p>
<blockquote>
<p>谷歌没有某个高高在上的领导体系，员工被极大地赋予决定权，所有员工都能够以创始人的思维工作。谷歌人在谷歌最根本的体验就是必须决定自己想要成为一名创始人—做创造性的工作，还是成为一名员工–完成工作指令。员工或许是所在团队某种有趣文化的缔造者，这个决定关乎的不是员工的实际所有权，而是做事的态度。</p>
</blockquote>
<p>建立杰出的团队或机构的起点是有一位创始人，但是成为一名创始人并不是意味着要建立一家公司。任何人都有可能成为一名创始人，也可以成为所在团队的文化创造者，不管你是一家创业公司的第一名雇员还是一家拥有数十年历史公司中的一员。</p>
<p>每一个人都应该在工作中能站在创始人的角度看待自己，或许不是一家公司的创始人，但是也可以成为一个团队，一个家庭或一种文化的创始人。<br><a id="more"></a></p>
<blockquote>
<p>战略有时只存在于一朝一夕，将易，战略改；文化则不同，文化具有持久性，是企业的根基。经受考验的时候，文化最为重要</p>
</blockquote>
<p>当年谷歌考虑停止运营中国大陆的搜索引擎，即是一个忠于企业文化，而非经济利益的决定。</p>
<blockquote>
<p>赋予工作意义，工作至少占据了我们生活的三分之一的时间和清醒时的一半时间。工作也应该不仅仅是一种达成结果的手段。然而在很多公司，员工工作仅仅是为了得到薪水。</p>
</blockquote>
<p>为何不这样想：如果你是一名管道工，你就是在改善人们的生活质量，保持他们家园的清洁和健康；如果你在生产线上工作，不管生产的产品是什么都将为人所用，帮助到他们。不管你在做什么，都会对某人有重要的意义。而你所做的这项工作对你也应该有重要的意义。</p>
<blockquote>
<p>聘用糟糕的员工就好似在锅里扔进了一颗老鼠屎，不仅自身的表现不佳，还会拖累周围人的表现、士气和精力。</p>
</blockquote>
<p>和更优秀的人一起工作，如果他们不及你优秀，暂时不用聘用，直到找到一个更优秀的人。短期内你们的工作会放缓，但最终你将建立一个更加强大的团队。</p>
<blockquote>
<p> 在谷歌成立初期，我们在招聘时更推崇精英主义，因此我们开始寻找一些表现出韧性和克服困难能力强的应聘者。现在我们更愿意聘用一位聪明、努力、在某州立大学毕业的尖子生，也不愿意聘用常春藤盟校的中等甚至中等偏上的毕业生。我们对大学教育背景的重视远不及对你取得的成就的重视。</p>
</blockquote>
<p>许多最优秀的人才并不在最好的学校里面读书。</p>
<blockquote>
<p>多数面试都是在浪费时间，因为99.4%的时间都用在证实面试官最初的10s的印象，不论印象好坏。同时，“请作一下自我介绍”，“你最大的缺点是什么？”，“你最大的优势是什么？” 这些问题也毫无价值。通过这些问题从应聘者身上得到的一些琐碎信息或洞察，仅仅使面试官以为自己聪明，得到自我满足，而这些问题对预测应聘者在未来工作中的表现几乎没有任何作用</p>
</blockquote>
<p>结合行为和情景结构化进行测试，评估应聘者的认知能力、尽责性和领导力。(eg.给我讲讲你曾经……)</p>
<blockquote>
<p>作为一名员工，我们希望收到公平的对待。如果某个比我贡献更多的人拿到比我高的薪水，我没有任何意见。但是如果某人与我做着同样的工作但却拿到比我更高的薪水，那我将会非常不开心。</p>
</blockquote>
<p>一个公正的考评体系意味着我不需要担心这些。考评同时还有利于员工在公司内部转岗。作为一名员工，我们相信员工升职是靠表现而不是靠耍政治手腕。对于一个小团队来说，并不需要这样的基础架构—你认识每一个人，但是一旦公司规模扩张到数百人，员工就更愿意相信一个可靠的体系而不是leader个人，并不是因为经理一定就是坏人或心存偏见，而是因为一个包含校准的考评流程能够有效消除坏的行为和偏见。</p>
<blockquote>
<p>如何提升团队的能力和表现？谷歌的做法是：关注表现最差和最优的两类员工。最差的员工可能是放错位置的天才，最优员工可能是未开发充分的宝藏。在谷歌，我们定期找出表现最差的5%左右的员工。这些员工在我们绩效分布的底端。要注意这个过程是在我们正式的绩效管理流程之外。</p>
</blockquote>
<p>我们的目的不是找出要解雇的人：我们要找出需要帮助的人。</p>
<blockquote>
<p>到哪里去寻找最好的老师，他们就坐在你的旁边，我向你保证，在你们的组织里有你们各个方面工作的专家，至少足够专业，可以教其他人。我们都熟悉最大值和最小值的概念。理论上讲，谁都希望有最优秀、具备最大化专业知识的人做培训。但是在数学领域，有一个经过提炼的概念：局部最大值。局部最大值是在一个限定范围内的最大值。最大的数字是无限的，但是1到10之间最大的数字是10.</p>
</blockquote>
<p>在你们公司，肯定有一位总销售量最高的销售人员。请这个人而不是从外面请人给其他员工授课，这样不仅有了一位比其他销售人员更优秀的老师，而且这位老师对你们的公司的特定环境以及顾客都了解。</p>
<blockquote>
<p>组织中大多数的个人表现符合幂律分布，即大部分的贡献由最优秀的少数员工，而非大批平均水平的员工做出。而多数组织都低估了最优秀的员工，给他们的奖励也有所不足，甚至还不自知。</p>
</blockquote>
<p>谷歌实行不公平薪酬，因为不公平薪酬恰恰是最公平的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书看似是给公司的团队leader看的，其实内容对于每一位工作的人都是受益的，我想这本书标题应该改为《重新定义自己在工作中的角色》 更为合适。</p>
<p>下面一些对我感触比较深的摘要，希望也能触动正在读本文的你，哪怕是一句。</p>
<blockquote>
<p>我们只需要坚信员工都是好的，再就是要有足够的勇气，把员工看成是企业主人翁，而不是把他们当成机器。机器会完成工作；主人翁会竭尽所能帮助企业和团队获得成功。</p>
</blockquote>
<p>人的一生大部分时间都在工作，但是对多数人而言，工作是一件痛苦的事情，只是一个谋生手段，其实不必如此。</p>
<blockquote>
<p>谷歌没有某个高高在上的领导体系，员工被极大地赋予决定权，所有员工都能够以创始人的思维工作。谷歌人在谷歌最根本的体验就是必须决定自己想要成为一名创始人—做创造性的工作，还是成为一名员工–完成工作指令。员工或许是所在团队某种有趣文化的缔造者，这个决定关乎的不是员工的实际所有权，而是做事的态度。</p>
</blockquote>
<p>建立杰出的团队或机构的起点是有一位创始人，但是成为一名创始人并不是意味着要建立一家公司。任何人都有可能成为一名创始人，也可以成为所在团队的文化创造者，不管你是一家创业公司的第一名雇员还是一家拥有数十年历史公司中的一员。</p>
<p>每一个人都应该在工作中能站在创始人的角度看待自己，或许不是一家公司的创始人，但是也可以成为一个团队，一个家庭或一种文化的创始人。<br>]]>
    
    </summary>
    
      <category term="读书笔记" scheme="https://emacs.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「七」：好事多磨]]></title>
    <link href="https://emacs.cn/2016/01/startup-7-good-things-never-come-easy/"/>
    <id>https://emacs.cn/2016/01/startup-7-good-things-never-come-easy/</id>
    <published>2016-01-05T14:03:37.000Z</published>
    <updated>2017-07-27T11:08:15.000Z</updated>
    <content type="html"><![CDATA[<p>当天晚上回来的路上，我和天一 一起等公交时，闲聊，“今年年会在一月底，时间过的真快，这也是你和我在多棱镜参加的第二个年会了”， “嗯”， 我问他，“对于15年，你试着用一句话或者几个字来总结下”，他略微停顿了下说：“现实还是和想象的不一样”，我笑着说：“不就是现实很残酷嘛”，他又略微停顿了下说：“以前认为技术上进步应该可以很快，但是现实发现不是这样”。我明白其义：“其实任何事情，任何领域，在你踏入的过程中总是很漫长的，且很艰难的，但是某一天某一刻你会突然发现自己领悟了很多，那一刻就是你成长的时候，然后进入下一个过程循环，过程总是漫长的，所以大部分人都处于这个过程中，就会出现 放弃 这个词，所谓好事多磨就是这个道理。”</p>
<p>这让我想起元旦前黑老三在微信群转发了任正非的一篇文章，让公司每一个成员都写一篇读后感时，我当时看了下标题，就没再打开，而是继续忙着手头上的事情，别误会，我并不是想说这篇文章表明的意思我不赞同，相反，正是因为我是对“傻”这个字理解不是处于字面上，而是已经践行多年。基于我和黑老三作战一年多时间的磨合，我相信这点互相了解的默契还是有的。本不想写这文，后来看了叫兽写得那篇长文，肺腑之言，有几点共鸣的地方，但是点太多，比较发散，尤其我和天一对话后，我想基于自己的经验和对任正非所说的“傻”，来谈谈我的理解。</p>
<a id="more"></a>
<p>什么情况下会被人说 “傻” ？ 那就是做了大家都不情愿干的事，而偏偏你自己去干了。</p>
<p>是不是可以这么认为？ 但是简单的一句话，却道出了很简单的道理，可以用几个词概括：努力、踏实、执行</p>
<p>我想，大部分人的智商都差不了太多，只要不是低于正常水平的智商就不会是真傻，既然不是真傻，那么那些智商和你差不多，又比你努力、踏实的人，哪个更容易成功呢 ？</p>
<p>我记得上次项目，在夜晚驱车赶回苏州的时候，黑老三和我说了些他在拿下这个项目的一些事情，有一点，我记忆非常深刻，当时这个项目还没拿下的时候，期间发生了件事，急需一样东西，但是辗转房间内，不停的电话，还是没解决，幸亏一位工作人员伸出援手，但是如果深入背后的细节，你却发现偶然中藏着必然，这是因为在这件事之前，这位工作人员一直在打包，搬东西，而黑老三当时在忙着项目的时候，也顺便帮忙了下，这就是所谓的“傻”， 但正因为这种“傻”，才有了别人的援手。</p>
<p>任正非的文中说，大多数企业自作“聪明”，往往将客户当“傻瓜”，骨子里认为客户是可以长期被忽悠、被欺骗的、被愚弄的。而这个其实是非常短视的。华为则将自己当做“傻子”，不愚弄客户。其实我一直坚信有一个词是非常值得韵味的：真诚。这个也是黑老三一直强调的，对待任何人要真诚，将心比心。客户也是同理， 把自己当做“傻子”，开诚布公。</p>
<p>对于身处初创企业的成员，每个人所期望的定是不一样的，但是，能力的提升都应该是大家所期望的，所以 “傻” 并不仅仅受益于公司，其实更多的是受益于自己。在你为公司坚守、执着和付出的时候，你自己的能力其实也在隐形的提升。</p>
<p>回到我和天一的对话，在任何事情，任何领域，目标明确，你只要去做就行了，好事多磨，总会有成功的一天。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当天晚上回来的路上，我和天一 一起等公交时，闲聊，“今年年会在一月底，时间过的真快，这也是你和我在多棱镜参加的第二个年会了”， “嗯”， 我问他，“对于15年，你试着用一句话或者几个字来总结下”，他略微停顿了下说：“现实还是和想象的不一样”，我笑着说：“不就是现实很残酷嘛”，他又略微停顿了下说：“以前认为技术上进步应该可以很快，但是现实发现不是这样”。我明白其义：“其实任何事情，任何领域，在你踏入的过程中总是很漫长的，且很艰难的，但是某一天某一刻你会突然发现自己领悟了很多，那一刻就是你成长的时候，然后进入下一个过程循环，过程总是漫长的，所以大部分人都处于这个过程中，就会出现 放弃 这个词，所谓好事多磨就是这个道理。”</p>
<p>这让我想起元旦前黑老三在微信群转发了任正非的一篇文章，让公司每一个成员都写一篇读后感时，我当时看了下标题，就没再打开，而是继续忙着手头上的事情，别误会，我并不是想说这篇文章表明的意思我不赞同，相反，正是因为我是对“傻”这个字理解不是处于字面上，而是已经践行多年。基于我和黑老三作战一年多时间的磨合，我相信这点互相了解的默契还是有的。本不想写这文，后来看了叫兽写得那篇长文，肺腑之言，有几点共鸣的地方，但是点太多，比较发散，尤其我和天一对话后，我想基于自己的经验和对任正非所说的“傻”，来谈谈我的理解。</p>
]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「六」：不合适就是不合适]]></title>
    <link href="https://emacs.cn/2015/10/startup-6-inappropriate-is-inappropriate/"/>
    <id>https://emacs.cn/2015/10/startup-6-inappropriate-is-inappropriate/</id>
    <published>2015-10-18T16:35:05.000Z</published>
    <updated>2017-07-27T11:08:00.000Z</updated>
    <content type="html"><![CDATA[<p>10.14号，周四，劝退了一位并肩了3个月的兄弟。这位兄弟做了一手好菜，人也不错，和团队成员相处融洽，但是在试用过程中发现和公司的职位要求有点距离，可能他在其他地方会有更好的发展，为了不耽误双方，就让去寻找更好的得方发展了。在劝退的那天，他租得隔间房被政府抢拆了，还记得那晚他发的朋友圈：”福无双至祸不单行~抬头的一片天，是男儿的一片天，是追梦的少年。 “，加油。</p>
<h3 id="辞职和辞退">辞职和辞退</h3>
<p>“不好意思，跟你提件事，我想离职…” ，我们很多人都是经历这个过程的，大部分都跳槽过很多公司，如果有下家，感觉跳槽是件很轻松的事，根本很少不考虑目前公司感受。从心理学角度分析：感觉提出离职是个很光荣的事（谁让你不器重我，此处不留爷，自有留爷处…）。</p>
<p>“不好意思，你不符合我们要求，你被辞退了…” ，对于这句话我相信大部分人都会很陌生，因为大部分人是很少被辞退的，就算被辞退，公司leader也很少这么直接，从大部分最初的管理者来说，劝退总是件开口比较难的事，尤其小公司，平时几个人相处比较好，你既要从公司角度考虑，又要还是保持朋友关系，好聚好散。</p>
<p>其实说到这，是想说明任何一个人都要为自己负责，为自己正在做的事负责，也要为所在的公司负责，这就是做人。从公司角度，有一个原则是不能被破的：不合适就是应该辞退，不合适就是不合适。<br><a id="more"></a></p>
<h3 id="用人原则">用人原则</h3>
<p>从“创业”公司角度，一个合格的员工，必须具备：</p>
<ul>
<li>做事的态度</li>
<li>不能把和工作无关的负能量带给他人</li>
</ul>
<p>这两个可以看作是原则问题，一经发现经过提醒不悔改必须辞退。</p>
<p>有了上面两个基本原则，再去观察这个员工是否有足够的热情投入到事业上来，这是评判一个员工是否热爱自己工作的一个因素，或者可以说真正能把自己而工作。可以说是非常好的加分项。</p>
<p>在整个过程中，要用最短的时间，给足他压力考验他与职位要求是否有距离，如果距离太大，需要过多培养成本，及时劝退。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>10.14号，周四，劝退了一位并肩了3个月的兄弟。这位兄弟做了一手好菜，人也不错，和团队成员相处融洽，但是在试用过程中发现和公司的职位要求有点距离，可能他在其他地方会有更好的发展，为了不耽误双方，就让去寻找更好的得方发展了。在劝退的那天，他租得隔间房被政府抢拆了，还记得那晚他发的朋友圈：”福无双至祸不单行~抬头的一片天，是男儿的一片天，是追梦的少年。 “，加油。</p>
<h3 id="辞职和辞退">辞职和辞退</h3>
<p>“不好意思，跟你提件事，我想离职…” ，我们很多人都是经历这个过程的，大部分都跳槽过很多公司，如果有下家，感觉跳槽是件很轻松的事，根本很少不考虑目前公司感受。从心理学角度分析：感觉提出离职是个很光荣的事（谁让你不器重我，此处不留爷，自有留爷处…）。</p>
<p>“不好意思，你不符合我们要求，你被辞退了…” ，对于这句话我相信大部分人都会很陌生，因为大部分人是很少被辞退的，就算被辞退，公司leader也很少这么直接，从大部分最初的管理者来说，劝退总是件开口比较难的事，尤其小公司，平时几个人相处比较好，你既要从公司角度考虑，又要还是保持朋友关系，好聚好散。</p>
<p>其实说到这，是想说明任何一个人都要为自己负责，为自己正在做的事负责，也要为所在的公司负责，这就是做人。从公司角度，有一个原则是不能被破的：不合适就是应该辞退，不合适就是不合适。<br>]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「五」：Done is better than perfect]]></title>
    <link href="https://emacs.cn/2015/09/startup-5-Done-is-better-than-perfect/"/>
    <id>https://emacs.cn/2015/09/startup-5-Done-is-better-than-perfect/</id>
    <published>2015-09-14T12:24:54.000Z</published>
    <updated>2017-07-27T11:07:51.000Z</updated>
    <content type="html"><![CDATA[<p>一直想写疯狂创业路的第五篇，却总是被各种琐事闯入，其实创业也就是这样，生活不可能是有条不紊的。</p>
<p>听着《Better man》整理这段时间的思绪… 12号早上为第一次参加上海国际马拉松进行了一次16KM的长跑训练，希望对自己的韧性、耐性进行一次挑战。</p>
<h3 id="团队">团队</h3>
<p>还是先从团队说起，经过一段时间拿捏，研发团队这块算是有点小有起色，什么叫小有起色？大家能把更多的注意力集中在产品和技术，而不是不断的招人，面试… 不过，这方面开始我承认对团队这块管理经验有所欠缺，还好，自己调整的也比较快，你要问我经验， 两个字: 人性 ，四个字：换位思考 。</p>
<p>不过问题还是很多，一方面：血液还是要经常调整，不适合的就是不适合，但是适合的就要让他留下来（这是对我的一个挑战，以前一个公司的leader，被同事说这不好，那不好，现在反过来思考，其实真正运营好一个公司，不可能不得罪人，很多人觉得你不好，可能只是他只是从自己的角度看了问题，而一个公司的管理者，更多时候是在平衡，而不是求完美） 招人不易，招适合的人更不易，下面一步棋得下的稳些。另一方面：整体拼劲还远不够，产品迭代速度有点慢。这两个方面是接下来着重加强的。<br><a id="more"></a></p>
<p>执行力很重要，其他次之，如果你的团队中有一个成员点子非常多，看起来是好事，但是对于创业就要小心了，点子如果很多，很容易导致团队分心，导致最后什么都没有做出来。创业者专注很重要。</p>
<blockquote>
<p>另外强调一点：不管任何时候，任何人都要分配平衡,这是创业的基本法则，切忌有分配不一致（大家能聚一起做事不易，不要因为这些事而影响大家）。</p>
</blockquote>
<h3 id="任务管理">任务管理</h3>
<p>这里要感谢下Teambition，强烈推荐。</p>
<p> <img src="http://ww3.sinaimg.cn/large/744e593bgw1ew24dc3jz5j214i0kowh8.jpg" alt="Task"></p>
<p>正常来说，我把任务版分成近期任务，本周任务，今日·未完成，今日·进行中，已完成</p>
<ul>
<li>近期任务： 所有突发奇想，或者拍脑袋的任务全部列在这边</li>
<li>本周任务:   本周需要完成的任务，周会中分工</li>
<li>今日·未完成：当日需要完成的任务，每日晨会中安排</li>
<li>今日·进行中：正在进行的任务，每人只有一个正在进行的任务</li>
<li>已完成：已经完成的任务，用于后期检查)]</li>
</ul>
<p>一方面此任务板能达到团队成员之间互相push的目的，另一方面,大家可以互相看到成员正在做什么，心里可以平衡任务的状态。</p>
<p>另外，这边有个注意点需要考虑，对于拍脑袋提出的需求可以先布置到近期任务中，如果比较紧急，那么必须和成员商量提前，其他任务切换到近期任务板，或者加班完成。</p>
<h3 id="产品">产品</h3>
<p>Done is better than perfect， 这是Facebook的标语，完成比完美更重要，从产品角度看，首先一个产品切忌一开始就想把它打造非常完美，大公司如此，小公司更应该如此，尽量避免死扣一些细节问题，为一些不必要的细节花太多时间。其次，切忌多方领导做产品，任何一款产品只能一个人主导，其他人只是建议。</p>
<p>另外补充一句：好多做技术的朋友创业的经过的时候，会说一句：运营非常重要，甚至最重要，我这里强调一点：运营是很重要，但是好的产品才是用户留存的关键，留存才是产品的王道。</p>
<p>对于一个开始主要切企业的产品，有一个问题是用户过于分散，就像俊元说的：如果你投一个广告，很多企业都能看到，那么这个过于理想了，永远不会有，所以永远是让我们的用户（企业）用完了我们的产品，然后如果觉得好，才去向外推荐，所以归结起来还是产品问题，toB的产品，品牌其实更重要，如上面所说，只有口碑好了，用户才会帮你推荐，会大大减少你额外的销售成本。</p>
<p>产品是最核心的东西，产品上对于销售的引导，远远比我们冲出去好得多。</p>
<h3 id="技术，数据时代的变化">技术，数据时代的变化</h3>
<p>引用舍恩伯格一个例子:<br>“大家应该知道jawbone，这个手环的制造商，他们也在搜集这些数据，比如你起床、运动频率等等数据。我们也可以搜集数据，然后进行分析。去年加州发生了地震，在加州有很多人都佩戴jawbone，他们不断的搜集自己的数据，而且地震发生的时候，是在午夜，他们搜集的数据有一个区县，可以看到这里用户的数量，他们戴着jawbone手环，在晚上三点钟的时候，应该是大家都在睡觉了，但是突然地震发生了，然后我们看到这个峰值，因为地震发生的时候，大家肯定要从床上跳下来逃生，大家就看到了这样一个曲线变化。为什么这个数据特别的重要？因为不同的颜色代表不同的城市。就告诉大家这个地震的程度有多少，在不同地区，这个地震是大还是小。jawbone的用户他们很好的捕捉到了地震的数据，甚至比政府做得还要好。甚至比政府地震仪捕捉到的数据做得更好。jawbone就想了，我们不仅可以来预测地震，因为它现在已经搜集到了这些地震的信息。但是实际上这些大数据给我们提供了一个现代平台，大家可能听说过一年多前谷歌收购了nest，它是生产恒温计的。其中一个创始人我也认识。这个恒温计是调节你在家里环境的温度，谷歌收购了这个品牌，他们花了三十亿美金投资到这个公司，大家就想了，30亿，就买了一个恒温计的制造商，真的吗？值不值这个钱？他们并不了解谷歌的想法，这实际上是一个智能恒温计，这个恒温计可以记得你整个温度的调节，它可以记忆你这一天之中，哪个时间段是调节了温度，因此它就可以捕捉这些数据，了解你的行为，不论是你在家里，回到家的时候，是你想要温度上升，或者是温度下降，它在了解你的习性，了解了这个习性之后，数据发送到总部。那么现在谷歌就获得了很多人在家里的温度的情况，而且在哪个时间段需要什么样的温度，这些数据都搜集到了，大家可以想象一下这些数据的价值有多少。这样大家可以通过这样的方式来进行能源保护，节省能源，比如说你可以采取一些环保的措施，这也是为什么谷歌收购了这个品牌。它实际上提供了一个全新的平台。”</p>
<p>No Data, No future. 如何利用现有的数据，让数据更好的服务于你的用户，是我们正在做的。</p>
<h3 id="沟通">沟通</h3>
<p>在我生日那天参加了一期沟通方面的课程，受益匪浅。有几点非常非常赞同：</p>
<ul>
<li>重复别人的话，让别人受重视</li>
<li>事实容易产生共识，意见容易产生争议，所以多论述事实，而不是意见</li>
<li>扬他人之长，避他人之短</li>
<li>先用别人喜欢的风格来进行沟通</li>
<li>正确的行为需要得到必要的反馈</li>
<li>激励成员时找准他真正的需求</li>
<li>一个成年人他说这个话多半是因为他得经历，人得经历不同，看事的角度也不同，没有必要证明他是错误的</li>
</ul>
<p>最后说两件值得开心的事，一个是：公司在2015创新创业大赛中踏入国家赛。另外一个是：公司整体进入统一战线期，这是相对于以前摸索方向，不断试错非常好的一件事。</p>
<p>不管怎么样，加油，每一天都是新的一天。</p>
<p><img src="http://ww4.sinaimg.cn/large/744e593bgw1ew26tpsdw3j20zk0qo40t.jpg" alt="NewDay"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直想写疯狂创业路的第五篇，却总是被各种琐事闯入，其实创业也就是这样，生活不可能是有条不紊的。</p>
<p>听着《Better man》整理这段时间的思绪… 12号早上为第一次参加上海国际马拉松进行了一次16KM的长跑训练，希望对自己的韧性、耐性进行一次挑战。</p>
<h3 id="团队">团队</h3>
<p>还是先从团队说起，经过一段时间拿捏，研发团队这块算是有点小有起色，什么叫小有起色？大家能把更多的注意力集中在产品和技术，而不是不断的招人，面试… 不过，这方面开始我承认对团队这块管理经验有所欠缺，还好，自己调整的也比较快，你要问我经验， 两个字: 人性 ，四个字：换位思考 。</p>
<p>不过问题还是很多，一方面：血液还是要经常调整，不适合的就是不适合，但是适合的就要让他留下来（这是对我的一个挑战，以前一个公司的leader，被同事说这不好，那不好，现在反过来思考，其实真正运营好一个公司，不可能不得罪人，很多人觉得你不好，可能只是他只是从自己的角度看了问题，而一个公司的管理者，更多时候是在平衡，而不是求完美） 招人不易，招适合的人更不易，下面一步棋得下的稳些。另一方面：整体拼劲还远不够，产品迭代速度有点慢。这两个方面是接下来着重加强的。<br>]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「四」：铁打的营盘，流水的'兵']]></title>
    <link href="https://emacs.cn/2015/05/startup-4-Iron-barracks-water-the-soldiers/"/>
    <id>https://emacs.cn/2015/05/startup-4-Iron-barracks-water-the-soldiers/</id>
    <published>2015-05-30T14:54:42.000Z</published>
    <updated>2017-07-27T11:07:42.000Z</updated>
    <content type="html"><![CDATA[<p>最近对这句话”铁打的营盘，流水的兵”理解越来越深刻，并不是因为这句话本身有多难理解，而是理解的角度会随着你正在做的事情越趋深刻。</p>
<h3 id="浮躁的现状">浮躁的现状</h3>
<p>公司人员流动一直很频繁，这应该不是只有我遇到的问题，大部分公司都会遇到，我有很多朋友也在创业，招不到人，应该说招不到合适靠谱的人，员工频繁流动，各种抱怨。但这又能怪谁，当大面积出现类似问题时，是应该反思是否是公司的问题了。公司的事我会娓娓道来，除了公司问题，还有很多其他现象，这里我先不扯远，我就说下我真实看到的现状。</p>
<p>我不清楚现在的人为什么如此浮躁。</p>
<a id="more"></a>
<p>1.之前iOS人员一直缺着，花了大量时间去招人，面了很多人，我发现大部分做iOS开发的都是快餐式培训出来的(补充一句,这里我没有说培训出来的不好)，而是很多人为了追求高薪，跨着专业去培训，连操作系统原理、数据结构、计算机网络都没搞懂，培训了3-4个月以为就可以拿高薪了，但是他们的以为还真有企业把他们的“梦想”变为现实。之所以这样，现今移动互联网创业大潮，导致做事的人少了，产品赶着要上架，又没人做，就死马当活马医了。更遇到很多刚刚培训出来的谎称自己已经有1年工作经验，还有自己是自学的，当我问到你是怎么自学的时候，就支支吾吾的了。做计算机这一行，并不是你学个计算机语言就可以搞定的事，如果你并不是真真喜欢这一行，纯粹的为了钱，完全不可能在这一行立足。</p>
<p>2.在招聘会的时候遇到一个作品还可以的设计师，然后也一起见面吃饭聊了也还不错，说好毕业后要来公司的，但是毕业后的一段时间内，发现无踪影了，一声招呼都不说，我们的一个产品还等着他开工。我在想 不管你不来的理由有千种，至少应该和我们打个招呼吧，这样我们会去另外想办法招人。</p>
<h3 id="聚集一批疯子">聚集一批疯子</h3>
<p>“让所有成员都可以看到就算现在做的事情失败，也没什么大不了的，因为只要团队在，再重新来又如何 ” 这是一个铁打营盘核心，但是打造这样的营盘何其容易，我们都知道这个社会是个现实社会，人现实，啥都现实，一个创业公司何来的凝聚力能让一帮疯子聚在一起 ? 暂不谈一群价值观相同的疯子，就说说正常来工作的吧，现在工作的人不外乎两类: 刚毕业的大学生和工作多年一直跳槽的人，这两类都有很强的差异性: </p>
<p>1.先说说刚毕业的大学生，这里只说多数情况，刚毕业的大学生，经验各方面都是不足的，创业公司招这些人其实成本还是挺大的，里面涉及很多的培养成本，但是也有很多能力很不错，基础很好，稍微培养下定是个不错的苗子。如果缘分好能遇到不错的久把他留下吧，其他的可以完全不用考虑，因为里面包含着各种不靠谱。</p>
<p>2.再说说工作经验还可以不断跳槽的人，尤其工作1-2年跳了很多次槽的，跳槽的原因无外乎两种原因，薪资问题或做的不爽。这里我不论具体跳槽原因的细节，如果创业公司想通过社招招来一批还不错的人，真是想当然了。 但是大部分时候真是没办法，总会遇到合适的，所以需要花大时间的面试。说到面试这里就又有Hire slow or Hire Fast的问题了.</p>
<h3 id="“Hire_slow，Fire_Fast”_OR_“Hire_Fast，Fire_Fast”">“Hire slow，Fire Fast” OR “Hire Fast，Fire Fast”</h3>
<p>Hire这一层是不包含试用期的，真正录用只有成为正式成员的时候，所以这里就不存在Hire slow和Hire Fast的问题了，三个月的试用期足够验证这个人是否合适了。一定要增加Hire难度，Fire的时候得速度。这一点得坚信不疑。</p>
<h3 id="人要沉淀，团队更要沉淀">人要沉淀，团队更要沉淀</h3>
<p>提起这个事，让我想到自己为了有块地方可以安静的深入研究存储辞职考北大信科，那1年多全部时间泡在图书馆里，有朋友事后对我说了句: 你值得吗，那年的时间基本浪费了吧。我心平气和带着微笑说：首先我做一件事只要不后悔就行，其次不管结果如何，对我来说，这个过程让我沉淀了很多，就比方说我的基础又扎实了不少，我一向认为，基础决定高度。这个就像你学任何东西，欲速则不达，那1年让我学会为了沉淀，让我有足够的时间反思。才让我现在安静下来专注做点事情。</p>
<p>人要沉淀，团队更要沉淀，这里就是在说到 “铁打的营盘，流水的兵”，用在创业公司尤其适合，什么是铁打的营盘 ？我认为在创业团队代表的就是种团队价值观及精神和制度，团队的成员是不停的流动的，毕竟做出一件成功的事情，必定是拥有为共同的价值观而奉献的一群疯子。一个靠谱的团队从0到1不可能始终是同一群人，来来往往，而在这过程中真正去铸造一个铁打的营盘。一个企业的文化大部分都是由几个核心创始人决定的，他们的想法，他们的执行力，他们的思维，来决定公司走向。整个团队打磨的过程中，自然而然很多好的东西会被沉淀下来，如果你不知道什么是公司的文化，你应该去一些公司去学习下，比如Google的“工程师文化”。</p>
<p>沉淀的东西不仅仅是软性的东西，还有很多硬性的，从技术角度看，如技术文档，代码规范，适合自己业务方面的框架等等。</p>
<h3 id="创业公司不易，慎重选择">创业公司不易，慎重选择</h3>
<p>大部分创业公司都还处在没有风投阶段，烧的是自己的钱，大部分都不是土豪，我曾待过一个创业公司，老板很多自己的东西抵押付工资，诸多不易。所以我真的很希望求职者真诚认真的对待这些创业公司。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近对这句话”铁打的营盘，流水的兵”理解越来越深刻，并不是因为这句话本身有多难理解，而是理解的角度会随着你正在做的事情越趋深刻。</p>
<h3 id="浮躁的现状">浮躁的现状</h3>
<p>公司人员流动一直很频繁，这应该不是只有我遇到的问题，大部分公司都会遇到，我有很多朋友也在创业，招不到人，应该说招不到合适靠谱的人，员工频繁流动，各种抱怨。但这又能怪谁，当大面积出现类似问题时，是应该反思是否是公司的问题了。公司的事我会娓娓道来，除了公司问题，还有很多其他现象，这里我先不扯远，我就说下我真实看到的现状。</p>
<p>我不清楚现在的人为什么如此浮躁。</p>
]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态分支预测]]></title>
    <link href="https://emacs.cn/2015/05/dynamic-branch-prediction/"/>
    <id>https://emacs.cn/2015/05/dynamic-branch-prediction/</id>
    <published>2015-05-10T04:24:29.000Z</published>
    <updated>2017-08-07T10:41:54.000Z</updated>
    <content type="html"><![CDATA[<p>说起这个话题也挺有意思，上周五我在公司技术分享的时候，在最末提到一个问题:<br>为什么排序过的数据在遍历的时候速度更快 ?<br>这里我拿出很久之前在Stack Overflow上火车在行驶的过程中的例子</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/744e593bgw1erz071og68j21520jp7b8.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz08s1yjaj21540ih7bj.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz08s1yjaj21540ih7bj.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1erz0a5681wj215a0mh7dc.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz0bo194hj214y0j7tel.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erz0dxmakaj214r0lun4t.jpg" alt=""></p>
<p>这里就有伙伴提出问题了，既然靠猜，火车如果发现目的地不是预期的，那么就说明猜错了，但是CPU怎么知道猜错了呢？ 这里就涉及到cpu的流水线.</p>
<p>比如一个分支代码: </p>
<figure class="highlight C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (data[j] &gt;= <span class="number">128</span>) {</div><div class="line">	sum += data[j];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从高级语言层来看，这段代码是只能顺序执行的，必须先检测条件，才能执行条件对应的语句. 但是从CPU角度来看，却不是这样，CPU会把这几条语句分成多条指令，取个简单例子:</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1erz14fsgxmj210b0cltc0.jpg" alt=""></p>
<p>为了提高CPU中存储器、译码等的效率，CPU可采取流水线方式，上面两条指令假设一个是判断指令，一个是预测指令。那么当判断指令取指时，预测指令什么都还没做，当判断指令译码时，预测指令才开始取指，当判断指令执行时预测指令开始译码，这个时候，判断指令要么true，要么false，如果true 说明预测的指令是对的，这样效率会很明显提高，反之如果是false，那么就要重新进行，并把 目标地址 缓存到一个存储器中。一直循环到最后，这样就很容易解释为什么排序过的程序遍历会更快了.</p>
<p>补充下测试代码:</p>
<pre>
<code class="C++">
int main()
{
        const unsigned arraySize = 32768;
        int data[arraySize];
        for (unsigned i = 0; i < arraySize; i++) {
                data[i] = std::rand() % 256;
        }
        //std::sort(data, data + arraySize);
        clock_t start = clock();
        long long sum = 0;
        for (unsigned i = 0; i < 100000; i++) {
                for (unsigned j = 0; j < arraySize; j++) {
                        if (data[j] >= 128) {
                                sum += data[j];
                        }
                }
        }
        double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;
        std::cout << "time = "<< elapsedTime << std::endl;
        std::cout << "sum = " << sum << std::endl;
}
</double></code>
</pre>

<p>在不sort的情况下和sort情况下可分别测试下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起这个话题也挺有意思，上周五我在公司技术分享的时候，在最末提到一个问题:<br>为什么排序过的数据在遍历的时候速度更快 ?<br>这里我拿出很久之前在Stack Overflow上火车在行驶的过程中的例子</p>
]]>
    
    </summary>
    
      <category term="cpu" scheme="https://emacs.cn/tags/cpu/"/>
    
      <category term="性能" scheme="https://emacs.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「三」：从"速度与激情"看团队]]></title>
    <link href="https://emacs.cn/2015/04/startup-3-from-fast-furious-Look-team/"/>
    <id>https://emacs.cn/2015/04/startup-3-from-fast-furious-Look-team/</id>
    <published>2015-04-19T15:24:04.000Z</published>
    <updated>2017-07-27T11:07:30.000Z</updated>
    <content type="html"><![CDATA[<p>今晚是第二遍看速7，不仅被剧情吸引，更被这样的团队所吸引， 或许是因为看到团队成员中自己的影子。</p>
<p>近期一直在忙着招聘的事，说实话，这真是个非常花精力的事情，而且你必须投入进去，因为没人会帮你去做，况且别人认为合适的，自己却不一定觉得他合适. 因为你们之间看到的点和面都可能不一样, 我看重的是他的综合能力如何，潜力，是否在团队中起个重要的角色等，别人看到的是可能是经验如何，性价比是否高…<br><a id="more"></a><br>继续先说说招聘的这个事：<br>首先，不能因为自己非常忙而不去浏览简历，等被面试的人过来才发现简历上的不合适。这个对双方都是非常浪费时间的。这个浏览简历一定要着重自己找人标准去浏览. 所以创始人的价值观非常重要. 用自己的价值观招的人，肯定也会是类似的.  (这里插一句: 加入创业公司，一定要和老板好好聊聊，如果他的价值观和你不对路，不要加入.) </p>
<p>其次，虽说招聘渠道能招到非常满意的基本上在10%的概率以下，但在你还没有更好的渠道之前，这个必须坚持去做，有些人的确是可遇不可求，不要认为牛人不会去投简历什么的， 我见过自己身边很多朋友，由于没有伯乐发现，但是自己个人性格问题，还是会去投简历到企业，这种人可能会在面试的过程中才能去发现他牛逼的地方. </p>
<p>再次，说个题外话，公司招人，一定不要为了临时需要一个就招过来，然后隔段时间事情做完后，就把人开掉，这是非常不道义的，也不适合团队发展，这个时候应尽量去外包给其他公司或者个人。</p>
<p>最重要的是，在面试过程中遇到还不错的，怎么“”拿下他” 才是重点，尤其是在公司资金还特别寒碜的情况下，每个人遇到的情况不一样，从我自身来看，可以提炼出几个词: “诚”，“兴趣”，“融入”，“价值”。</p>
<p>说说团队效率问题：<br>说个发生在现实中的一个对白:<br>A: “他们怎么下班后就走了呢”.<br>B说：”我分配的事情事情做完了当然可以走了”,<br>A继续问:”那是不是分配的任务还不够多?”<br>B反问:”难道你非要他们天天加班，你才满意哈.” ….</p>
<p>主要想说一点，每个人都想打造一个凝聚力很强的团队，但是实际上结果却是一个诚惶诚恐为你打工的团队。大部分时候都要从质去考虑事情，而不是量，无论从长期还是短期来看，工作的时间越长，效率是越低的，这里就涉及到一个拖延症，总想着任务可以在晚上还有时间可以解决，导致每个成员心理有个念头。拖延症毛病越来越严重，就算给你再多时间，也可能无法按时完成任务. 如果时间控制的刚好，那么每个人做事的起来就会速度很多，导致他自身能力也会提高，他能力的提高不仅对他个人，提升整个团队士气和水平是最关键的。加班这东西本身就是个破坏别人生活的事情，更多的要营造一个工作成为生活的一部分的环境。这个才是关键。</p>
<p>上面只是蜻蜓点水的说了下建立团队中的招聘和成员效率的一些可能你会碰到的问题，当然如果你愿意和我细细交流，可以留言。 很多事情不是只言片语就可以描述的。</p>
<hr>
<blockquote>
<p>无论你身处何方，无论是四分之一英里的赛道，还是绕了大半个地球的距离。我们生命中最重要的东西就是这屋檐下的人，就在此时，就在此地，你永远在我身边，也永远是我的兄弟 ！ </p>
</blockquote>
<p>我所期望的团队成员应该具备：</p>
<p>价值观一致、责任感、能力相差不大、成员之间优势互补、再加一句称不上 “出生入死” 但应该是 “同舟共济” 。</p>
<p>始终相信，只要团队不散，一个项目即使失败，大不了再起一个项目. </p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1erbawp9g2ij20di04v3z4.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今晚是第二遍看速7，不仅被剧情吸引，更被这样的团队所吸引， 或许是因为看到团队成员中自己的影子。</p>
<p>近期一直在忙着招聘的事，说实话，这真是个非常花精力的事情，而且你必须投入进去，因为没人会帮你去做，况且别人认为合适的，自己却不一定觉得他合适. 因为你们之间看到的点和面都可能不一样, 我看重的是他的综合能力如何，潜力，是否在团队中起个重要的角色等，别人看到的是可能是经验如何，性价比是否高…<br>]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「二」：14年末微传播失败--手写字祝福贺卡(书心)]]></title>
    <link href="https://emacs.cn/2015/04/startup-2-14year-shuxin-failed/"/>
    <id>https://emacs.cn/2015/04/startup-2-14year-shuxin-failed/</id>
    <published>2015-04-11T05:52:48.000Z</published>
    <updated>2017-07-27T11:07:20.000Z</updated>
    <content type="html"><![CDATA[<p>14年7月份左右，一个叫“围住神经猫”的H5的游戏在微信刷屏…此后, 这种传播方式被认为是’性价比最高’的方式.</p>
<p>14年末的时候，也就是情人节和新年快到的时候，我们也是脑袋一拍，制作个新年手写送祝福如何 ? 几个人稍微讨论下，我就开始写了，一个人大概断断续续花了两周时间(创业就是这样, 期间还有其他事情，永远不可能纯粹)， 最后上线的时候通宵了两晚，终于上线了.<br><a id="more"></a></p>
<p><img src="http://ww2.sinaimg.cn/large/744e593bgw1er1ku109xkj20hs0vkdhb.jpg" width="50%" height="80%"><br><img src="http://ww4.sinaimg.cn/large/744e593bgw1er1ktduayoj20hs0vktaq.jpg" width="50%" height="80%"><br><img src="http://ww2.sinaimg.cn/large/744e593bgw1er1lapv0cdj20hs0vk0vx.jpg" width="50%" height="80%"></p>
<p>javascript模拟毛笔字核心算法已开源:<br><a href="https://github.com/vimer/handWritingWithJS" target="_blank" rel="external">handWritingWithJS</a></p>
<p>上线后发现根本不是我们想的那样, 也就公司几个人在帮忙宣传传播着，但是几乎很难看到朋友圈其他人在分享. </p>
<p>私下沟通了一些朋友, 原因主要是两点:</p>
<ol>
<li>自己的字本身写的不好, 不愿意分享的占 80% </li>
<li>不知道写些什么</li>
<li>喜欢1对1发送给朋友</li>
</ol>
<p>所以这次尝试短期而言可以说是失败的，当时选择这个切入是没错的， 但是产品是有问题的.</p>
<p>首先，微信上容易被大家传播的通常是那种简单粗暴风格的, 不用大家费多少脑筋，且有对比数据，让大家形成攀比. 而我们这个，得要求你写字好看，才能让自己觉得舒服, 才会去分享. 所以写字本身没错, 但是不要过于追求字的真实还原度，可以让写出的字都比较好看，然后人与人之间也能形成差异. 更重要的一点是不要让应用学习成本增加，一定要易上手. 如果把APP的内容搬到这里来不是不可以，而是为了做推广，就不适合这样.</p>
<p>其次, 如果写一个字还好, 让用户去写一段字, 又是比较费劲的事, 比如足记，用户可以自己写，也可以直接选现成的. 这一点上其实是犯了一个产品设计的大错, 千万不要在这种适合交给用户太多空间. </p>
<p>最后我想说一句, 任何产品想一日爆红的念头是非常愚蠢的, 中国人创业很多都有赌徒心态, 没有踏踏实实做好产品的心态.这几天接触股票, 说句实在话, 想创业就不要炒股, 反之亦然… </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>14年7月份左右，一个叫“围住神经猫”的H5的游戏在微信刷屏…此后, 这种传播方式被认为是’性价比最高’的方式.</p>
<p>14年末的时候，也就是情人节和新年快到的时候，我们也是脑袋一拍，制作个新年手写送祝福如何 ? 几个人稍微讨论下，我就开始写了，一个人大概断断续续花了两周时间(创业就是这样, 期间还有其他事情，永远不可能纯粹)， 最后上线的时候通宵了两晚，终于上线了.<br>]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创业路「一」：24pi - 团队合作才能大作, 这是种胸怀]]></title>
    <link href="https://emacs.cn/2015/03/startup-1-24pi-tearm-will-be-great/"/>
    <id>https://emacs.cn/2015/03/startup-1-24pi-tearm-will-be-great/</id>
    <published>2015-03-08T06:34:48.000Z</published>
    <updated>2017-07-27T11:07:10.000Z</updated>
    <content type="html"><![CDATA[<p>直接从大三的创业项目过渡目前这个创业, 来的的确有点快, 本来想一一娓娓道来，但24pi这个产品牵动着核心成员及几十万粉丝的心，请允许我写个总结. 之前的创业产品和项目一些靠谱经验会慢慢补上.</p>
<h3 id="一、产品">一、产品</h3>
<p>####1.需求分析<br>首先24pi在需求分析上做的不好，那时就是一个idea，飘飘洒洒发散了一下，就抗几把枪开始干了. 导致后来走了一段弯路, 还好发现的时候开发的周期不长, 变道比较快，如果已经开发了很长一段时间了，那么成本就上去了。 所以需求分析必须重视  !</p>
<p>需求分析阶段我的建议是多次头脑风暴来不断细化产品. 不断庖丁解牛，对于细化产品得粒度及广度是和几个核心人员的经验有关的, 如果第一次你可以尝试从调查目标人群、 自己身边普通用户进行黑箱调查… 切忌拍脑袋做产品.<br><a id="more"></a></p>
<p>####2.产品交互原型<br>这里要谈谈产品原型的重要性，产品原型制作时间相比较开发时间是非常少的，但是又是非常接近于成品的一个东东，所以如果原型制作非常熟练建议还是必须先出原型，再不行直接草稿也行。最好得方式是先草稿，设计根据草稿做出设计图，然后再出整个产品原型交互原型，整个过程控制在非常短得时间内，如果和大家协商没问题就可以开发了。不然你会发现开发人员不停的在需求上进行改动，一会加，一会不加… </p>
<p>####3.产品迭代周期<br>由于互联网的变化速度之快, 建议每周迭代一个版本, 周五开发结束，周末测试, 周一发布.</p>
<p>####4.试错<br>试错对于任何的产品都会有, 这里我强调的是快而准, 快和准是和上一条迭代周期有关的, 每发布一个迭代版本，定会有即时用户反馈和功能统计数据, 根据这些在初心不变的情况下做一些小步更改. 当然如果大方向发现有问题要立即停止.</p>
<p>另外提醒下:有些事试错成本远大于事后获取的经验值,更多时候需要的是自己的一份睿智而不是经验.</p>
<p>####5.头脑风暴<br>对于头脑风暴, 我建议两周一次, 主要用于核心成员对于产品方向的总结和信息对称.还有一个是成员之间信心的互相支撑.</p>
<p>####5.做好产品,切忌浮躁<br>其实世间不会亏待你的努力的, 开始我认为得到第三方应用市场推荐需要花钱, 后来我错了, 因为等我们上线几周后,在没有推广的情况下, 最美应用、小米市场等第三方都给与了推荐.这对我们来说已经是不小的精神上支持了.<br><img src="http://ww3.sinaimg.cn/bmiddle/744e593bjw1emxi1ic0vnj20f00qomzx.jpg" alt="最美"><br><img src="http://ww1.sinaimg.cn/bmiddle/744e593bgw1emt68iga1ij20t20f3q5o.jpg" alt="小米"></p>
<p>所以我觉得，如果你的产品需要广告或者需要营销人员去推销,就说明你的产品还不够好,科技应用于商业应该主打产品开发，而不是分销. 只要用心做一件事, 包括产品, 定会有人帮你的产品说话的.(这里不是强调不需要运营,其实运营和产品同样重要,这里只是说要强化产品)</p>
<p>###二、技术<br>其实技术对于移动互联网创业这块是个非常重要的一环. 问题很多 .</p>
<p>对于初创公司在开发速度上不仅仅要快，更重要一点是要更多得构建基础框架，为之后的开发节省更多时间成本. 这件事需要技术负责人必须做. </p>
<p>这里只强调技术负责人的角色, 因为一个领导者不仅仅是个称号。而是一个责任 !!</p>
<p>当产品原型出来后，下面一步是技术负责人做的事，必须拆解产品，让需求功能化，哪些能做，哪些更容易做，哪些不能做，技术怎么选型，制定开发周期，督促整个开发周期，协调开发人员，技术难点突破，技术文档实现，技术标准等等都是的. 不是仅仅安排事这简单.</p>
<p>其实还包含团队的技术氛围、团队成员的能力提升等软性方面的，如果想做个称职得技术负责人这些都是必须要做且要做好的 !</p>
<p>我觉得让一个成员喜欢上这里，不是因为薪资，而是因为爱这里，这段经历可以让他提高自己,这个才是他拥有的财富.</p>
<p>###三、用户<br>对于用户，我喜欢用粉丝这词. 而且现在团队成员也渐渐喜欢用粉丝代替用户.<br>我个人比较喜欢或者说非常喜欢和粉丝打交道，我觉得一个做产品的人不和粉丝打交道那么产品肯定是做不好的. 因为粉丝是最初的需求来源 。他们得需求可能不是他们真正想要的, 但是你可以思考用户背后的真正需求. </p>
<blockquote>
<p>对于粉丝我觉得一定要善于运营, 和传统的运营区别在于, 四个字 “以情动情”<br>只有真诚的对待用户, 用户也会真诚*10倍得对待你, 或许这就是小米所说得参与感. </p>
</blockquote>
<p>下面两张是其中两个粉丝对24pi的评价.<br><img src="http://ww3.sinaimg.cn/large/744e593bgw1epyb1n4t0rj20al0dgdhf.jpg" alt="努力"></p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1epyb3zj28wj20au0e9jsq.jpg" alt="努力"></p>
<p>有人觉得和用户沟通是客服的事, 应该招个人或者让运营的人来专门负责这个事, 对于这种观点我不赞同, 如果这个事是大公司还可以理解，对于初创公司，尤其种子用户阶段，这件事必须亲力亲为.况且不用花太多时间, 需要的只是坚持.</p>
<p>我喜欢他们.</p>
<p>###三、团队<br>团队 !</p>
<p>标题说了, 团队合作才是大作, 这是种胸怀 .</p>
<p>以前我一直觉得自己适合且擅长一个人作战 ! 自己一个顶3-5人是没问题的，所以之前的创业大部分是我1个技术再加其他运营、产品等等. </p>
<p>不过我现在思路有改变，我的想法是自己一个人作战是错误的, 但是也不适合和普通人(对技术没感觉，效率比较低)一起作战. 因为所谓木桶的短板效应, 一个桶的水的多少还是和最短得板有关系，还有一点是和技术不在一个水平线的人共事协调起来非常费时费力. 宁愿自己抗起他那部分任务对我来说只不过是多写会代码的事, </p>
<p>所以这边要说的是团队成员的招聘.</p>
<p>对于初创公司，招聘这件事是最头疼的一件事, 尤其在核心成员还没全部出现得时候, 最好得建议是多花时间招人. 招聘渠道最靠谱的是从自己身边找 . 身边的好友等等. 只有把头几个核心成员凝聚起来, 这个就像个风眼, 周边的风暴会围绕这个风眼来聚起来, 而且越聚越大 .</p>
<p>团队核心成员的聚集关键在于价值观的统一, 价值观如果统一那么其他条件都是次要的,  这里我强调价值观. 什么是价值观,  这里最重要一点是目标统一 ! 在关键时刻尤其公司缺钱时能共患难. 这样的团队就算还没作品，VC也会欣赏的.</p>
<p>对于团队还有一点要说的是团队成员的融入. 这一点是我们要改善的地方.  关于融入最直接的是提高成员的积极性. 那么如何提高积极性我思考了几点:</p>
<ul>
<li>让开发人员体验式开发, 重点在于参与感, 体验产品开发的后获取的成就感</li>
<li>提升成员技能, 让他每周都能学到东西, 而不是机械式的开发. 这里强调分享会 和 团队成员之间的协助</li>
<li>多和成员进行沟通, 不要拘泥于形式 可以在一起走路时多沟通最近想法 这个话题可以围绕工作  生活 学习 展开 从这些可以预判成员的行为. </li>
</ul>
<p>对于团队成员的离开, 我觉得没必要去担心, 可以用朱念洋的一句话总结下: “走了得人, 公司后面是成是败, 也都与你无关。 留下来的, 当年咋们共苦, 成了咋们共甘.”</p>
<p>###四、协作<br>对于团队协作我倾向于大家能够互相push对方(当时我只知道“敏捷开发”这个词而没有过多的了解他) 后来了解到Scrum, 引入了周会和每天站会。所谓敏捷就是要提高开发效率,这个开发效率就是为了保证产品的快速迭代.我们是每周必须迭代一个版本,这样可以让用户知道我们一直在更新这款软件(就算用户很少,也得做)我们用心在改进.<br>这里推荐teambition做敏捷开发的管理平台.</p>
<p>###五、对于加班<br>我是很愿意把自己的青春奉献给自己喜欢做得事情,想必大家也一样,但是如果无畏着为了加班而加班,我是非常不赞同的.很长一段时间我们团队就存在这样毛病,最后形成每天大家都是20-22点才下班.把工作当做人生意义的一部分但不是全部.</p>
<p>###六、关于打卡<br>对于技术团队,我是非常讨厌打卡的,对于这件事肯定很多人和我一样,但是如果从公司角度考虑还是有必要的,前面我说道不是每个人都能自我约束自己,打卡可以起到一定的警惕作用。(不要把考勤和工资挂钩就好),当然最好的方式是弹性工作制, 去掉打卡必须首先工程师得自律.</p>
<p>###七、创业场所<br>其实我觉得最好得创业场所是两层楼上面可以住下面是可以办公和运动的. 公司里面可以住不仅仅是吃苦问题，而是减少花在来回家和公司之间的时间成本. 不用折腾. 创业在拼得时候更应该是累了睡，休息好了继续 …<br>曾有几天为了快速把pi行榜上线，带了自己帐篷在公司里面睡了2天多<br><img src="http://ww1.sinaimg.cn/large/744e593bgw1epybmzhp0pj20h70gejt8.jpg" alt="帐篷"><br>其实根本不算什么, 如果公司可以洗澡我非常喜欢这样的生活. 我宁愿天天住公司.<br>另外还强调一点是 公司需要给成员提供必备的运动环境或者时间. 因为健康永远是第一的. 如果长期不运动这么拼得搞事业 很容易把自己身体搞垮的，得不偿失，有张有弛才是, 这里不分创业公司和上市公司, 只要是公司这种条件提供是应该的.</p>
<p>虽然目前的创业场所不是特别合适我, 但已经不错了，坐落在黄浦江边. 平时可以眺望下.<br><img src="http://ww4.sinaimg.cn/large/744e593bgw1epybvgq33yj20vk0no78i.jpg" alt="环境"></p>
<p>###八、对于自己<br>一直认为自己善于管理，尤其善于观察他人的心理 . 但是自己短板在于是懒得沟通.  对, 是 “懒”! 因为自己以前一直在做技术,  天天和计算机用0和1沟通, 把自己所负责的事情发挥到极致. 这是以前喜欢做的. 现在更多得要担起公司的责任. 从公司整体利益出发, 所以 让自己沟通起来 ! </p>
<p> 这里说到沟通, 不得不说一句, 一定是有效的沟通, 而不是废话. 我不喜欢“说的多,看的多, 做的比较少得人” ，  而且永远不喜欢. 所以自己肯定不会往这方面发展,  我希望自己能尽量一句话表达自己观点, 或者用尽量简短得话来说事, 大部分时间还是放在执行上.</p>
<p>最后对自己说一句: 对坚持最大的鼓励,不是“你可以”, 而是多年后说一句:”还好你没放弃”.</p>
<p>另外,团队不断招人 , 只要你认同我价值观, 只要你足够优秀. 把简历砸过来吧.<br>Android，iOS，后端, 设计…<br>emacs#vimer.org</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>直接从大三的创业项目过渡目前这个创业, 来的的确有点快, 本来想一一娓娓道来，但24pi这个产品牵动着核心成员及几十万粉丝的心，请允许我写个总结. 之前的创业产品和项目一些靠谱经验会慢慢补上.</p>
<h3 id="一、产品">一、产品</h3>
<p>####1.需求分析<br>首先24pi在需求分析上做的不好，那时就是一个idea，飘飘洒洒发散了一下，就抗几把枪开始干了. 导致后来走了一段弯路, 还好发现的时候开发的周期不长, 变道比较快，如果已经开发了很长一段时间了，那么成本就上去了。 所以需求分析必须重视  !</p>
<p>需求分析阶段我的建议是多次头脑风暴来不断细化产品. 不断庖丁解牛，对于细化产品得粒度及广度是和几个核心人员的经验有关的, 如果第一次你可以尝试从调查目标人群、 自己身边普通用户进行黑箱调查… 切忌拍脑袋做产品.<br>]]>
    
    </summary>
    
      <category term="创业路" scheme="https://emacs.cn/categories/%E5%88%9B%E4%B8%9A%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB Map-Reduce 原理及提速]]></title>
    <link href="https://emacs.cn/2015/01/mongodb-map-reduce-increase-speed/"/>
    <id>https://emacs.cn/2015/01/mongodb-map-reduce-increase-speed/</id>
    <published>2015-01-18T04:07:42.000Z</published>
    <updated>2017-08-05T16:27:12.000Z</updated>
    <content type="html"><![CDATA[<p>想要优化Map-reduce就要深入理解其原理.<br>Map-Reduce基本原理请见下图:</p>
<p><img src="http://okf337562.bkt.clouddn.com/map-reduce.jpg" alt="Map-Reduce基本原理"></p>
<a id="more"></a>
<p>整个数据处理流程可以参见官方上图,先对要进行处理的数据进行Query,然后针对Query的数据进行map,最后针对map的数据进行reduce.</p>
<p>简单了解之后,我们这里取一个例子熟悉下整个过程:</p>
<p>数据基本格式为:</p>
<pre>
<code class="js">
/* 0 */
{
    "code" : "A",
    "uid" : "id_1",
    "count" : 1
}

/* 1 */
{
    "code" : "A",
    "uid" : "id_1",
    "count" : 1
}

/* 2 */
{
    "code" : "B",
    "uid" : "id_1",
    "count" : 1
}

/* 3 */
{
    "code" : "B",
    "uid" : "id_2",
    "count" : 2
}
</code>
</pre>

<p>目的:根据uid计算出count的和 且 这个合涉及到哪些code.</p>
<p>很快就可以写出Map和Reduce函数:</p>
<pre>
<code class="javascript">
var map = function() {
    emit(this.uid, {"code":this.code || "", count:this.count || 1});
};

var reduce = function(key, values) {
    var result = {code:{}, count:0};
    values.forEach(function(val) {
                result.code[val.code] = 1;
                result.count += val.count;
                });
    return result;
}
</code>
</pre>

<p>结果为:</p>
<pre>
<code class="javascript">
/* 0 */
{
    "_id" : "id_1",
    "value" : {
        "code" : {
            "A" : 1,
            "B" : 1
        },
        "count" : 3
    }
}

/* 1 */
{
    "_id" : "id_2",
    "value" : {
        "code" : "B",
        "count" : 2
    }
}
</code>
</pre>

<p>这次我省去了query的过程,直接进行Map和Reduce,我们来拆解下过程:</p>
<p>首先,MongoDB会扫描整个数据表(这里省去Query)遍历所有documents,对于每个docuemnt都会根据key(uid)进行map存储.</p>
<p>其次,这个时候MongoDB会对记录的size进行检查( mongod checks every 100 records that the size of the map is not over 50KB, if so it runs reduce on ALL current keys. If size of map is still over 100KB, it dumps all current documents to disk in an “incremental” collection.)</p>
<p>最后根据map的数据进行reduce操作.</p>
<p>好,上面三点是大概的过程,对于Mapping过程,上面实例中会进行</p>
<pre>
<code class="javascript">
{"id_1", values:[{"code":"A", "count":1}, {"code":"A", "count":1}, {"code":"B", "count":1}}
</code>
</pre>

<p>这样的Emit操作.这点是需要注意的.然后以这样得方式传入到Reduce进行处理,所以Reduce必须对values进行forEach处理.</p>
<p>通过上面这个过程,还有一点要非常注意:如果有很多文档,而且这些文档的分布是非常随机的,当内存比较小时,MongoDB会采取把这些数据存在一个inc自增的文档中.</p>
<p>比方说:我有A, B, C三个key, 每个key有100个, 但是这些key都是随机分布的 比如A…B…A…B..C…A..B..C..当我要先对A进行Emit时需要把所有是A的key的document获取出来,那么这个过程当内存很小时 需要把大部分得document存储到磁盘上.然后内存和磁盘一直交换数据,至到把A全部找出为止(期间每在内存中操作的部分A会先Emit出去).</p>
<p>这种操作肯定很耗时, 如果我们对key进行索引且排好序,那么排好序的A就会大部分在内存中,减少了内存和磁盘的切换次数.</p>
<p>所以对大数据加排序是必须要有的.这个细节至少可以提高很多倍得处理速度.</p>
<p>基本原理先说到这,还有更多实践干货留着下次说.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想要优化Map-reduce就要深入理解其原理.<br>Map-Reduce基本原理请见下图:</p>
<p><img src="http://okf337562.bkt.clouddn.com/map-reduce.jpg" alt="Map-Reduce基本原理"></p>
]]>
    
    </summary>
    
      <category term="Map-Reduce" scheme="https://emacs.cn/tags/Map-Reduce/"/>
    
      <category term="MongoDB" scheme="https://emacs.cn/tags/MongoDB/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js异步回调池, Maximum call stack size exceeded error]]></title>
    <link href="https://emacs.cn/2015/01/rangeerror-max-call-stack-size-exceeded-error/"/>
    <id>https://emacs.cn/2015/01/rangeerror-max-call-stack-size-exceeded-error/</id>
    <published>2015-01-17T08:12:17.000Z</published>
    <updated>2017-07-27T11:06:52.000Z</updated>
    <content type="html"><![CDATA[<p>这种错误主要发生在js调用栈的限制,如下面递归调用的代码:</p>
<pre>
<code class="javascript">
(function a() {
    a();
})();
</code>
</pre>

<p>但是在Node.js中除了因为调用栈限制导致这种错误,还会因为异步回调的池满了导致这个问题,正常来说每个异步函数调用的回调函数,基本都是由事件触发回调的,这些事件触发器存在于一个地方,异步回调完成后,这个内存才会被回收.<br><a id="more"></a></p>
<p>比如下面这种代码:</p>
<pre>
<code class="javascript">
for (var i=0;i< docs.length; i++) {
    mongo.test.insert(docs[i], function(err, docs) {
        //....
    });
}
</code>
</pre>

<p>如果length=10000,瞬间发起这么多个异步操作,异步回调池肯定就满了,但是如果这些异步操作,1个完成之后发起下一个,这样池肯定没问题.</p>
<p>解决这种问题得方法:</p>
<blockquote>
<p>1.可以使用队列批量回调,限制在回调池大小之内<br>2.同步每一个回调</p>
</blockquote>
<p>有两个现成得module可以解决这种问题:</p>
<pre>
<code class="nodejs">
/*bagpipe*/
var async = function(val, callback) {
    setTimeout(function() {}, 1000);
}
var bagpipe = new Bagpipe(500);
for (var i=0; i< docs.length; i++) {
    bagpipe.push(async, docs[i].value, function(callback) {

    });
}

/*async*/
var q = async.queue(function(task, callback) {
    setTimeout(function() {
        log.info(task);
        callback(null, {});
    }, 5000);
}, 10);
q.drain = function() {
    log.info("finish");
}
for (var i=0; i< 100; i++) {
    q.push(i, function(err, data) {

    });
}
</code>
</pre>

]]></content>
    <summary type="html">
    <![CDATA[<p>这种错误主要发生在js调用栈的限制,如下面递归调用的代码:</p>
<pre>
<code class="javascript">
(function a() {
    a();
})();
</code>
</pre>

<p>但是在Node.js中除了因为调用栈限制导致这种错误,还会因为异步回调的池满了导致这个问题,正常来说每个异步函数调用的回调函数,基本都是由事件触发回调的,这些事件触发器存在于一个地方,异步回调完成后,这个内存才会被回收.<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="https://emacs.cn/tags/Node-js/"/>
    
      <category term="异常" scheme="https://emacs.cn/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js和cpu密集型计算]]></title>
    <link href="https://emacs.cn/2014/12/nodejs-cpu-cal/"/>
    <id>https://emacs.cn/2014/12/nodejs-cpu-cal/</id>
    <published>2014-12-27T11:35:46.000Z</published>
    <updated>2017-08-05T15:45:55.000Z</updated>
    <content type="html"><![CDATA[<pre>
<code class="javascript">
setTimeout(function () {
    for (var i = 0; i < 10000000000; i++) {
        //CPU密集
    }
}, 200);

setTimeout(function () {
    console.log('210 ms...');
}, 210);
</code>
</pre>

<p>这个小例子很经典的解释了Node.js遇到密集型CPU的时候问题,这个程序分别在两个时间点触发,虽然在210ms得时候回调内得程序执行非常很快,但是在200ms得时候处理了一个CPU非常密集型的任务就导致整个线程阻塞了.<br><a id="more"></a> </p>
<p>至于Event Loop机制可以参考:<br><a href="http://www.infoq.com/cn/articles/nodejs-weakness-cpu-intensive-tasks" target="_blank" rel="external">http://www.infoq.com/cn/articles/nodejs-weakness-cpu-intensive-tasks</a><br>这篇文章中关于<strong>Event Loop和Tick</strong>的一段:</p>
<blockquote>
<p>每个Node程序的主线程都有一个event loop，JavaScript代码全在这个单线程下运行。所有的I/O操作以及对本地API的调用，或者是异步的（借助程序所在平台的机制），或者运行在另外的线程中。这全都是通过libuv处理的。所以当socket上有数据过来，或本地API函数返回时，需要有种同步的方式调用对刚发生的这一特定事件感兴趣的JavaScript函数。</p>
<p>在发生事件的线程中直接调用JS函数是不安全的，因为那样也会遇到常规多线程程序遇到的问题，竞态条件、非原子操作的内存访问等等。所以要以一种线程安全的方式把事件放在队列中，如果写成代码，大致应该是这样的：</p>
</blockquote>
<pre>
<code class="c">
lock (queue) {
    queue.push(event);
}
</code>
</pre>

<p>然后在执行JavaScript的主线程中（即event loop的c代码）：</p>
<pre>
<code class="c">
while (true) {
    // tick开始
    lock (queue) {
        var tickEvents = copy(queue); 
        // 将当前队列中的条目复制的线程自有的内存中
        queue.empty(); // ..清空共享的队列
    }
    for (var i = 0; i < tickEvents.length; i++) {
        InvokeJSFunction(tickEvents[i]);
    }
    // tick结束
}
</code>
</pre>

<blockquote>
<p>while (true) (在真正的node源码中并不是这样的；这里只是为了说明)表示event loop。里面的for为队列中的每个事件调用JS函数。Event loop在每个tick中都会调用与外部事件相关联的零个或多个回调函数，一旦队列被清空，并且最后一个函数返回后，tick就结束了。然后回到开始（下一个tick），重新开始检查其它线程在JavaScript运行时加到队列中的事件。</p>
<p>那么这个队列中的东西都是谁放进来的呢？</p>
<p>process.nextTick<br>setTimeout/setInterval<br>I/O (来自fs、net等)<br>crypto中的CPU密集型函数，比如crypto streams、pbkdf2和PRNG<br>所有使用libuv工作队列异步调用C/C++库的本地模块<br>同样下面代码当调用t1接口时也会导致t2的接口变慢.</p>
</blockquote>
<pre>
<code class="nodejs">
 app.get("/t1", function* (next) {
    for (var i=0; i< 5000000000; i++) {
        //cpu密集型
    }
    console.log("t1");
});
app.get("/t2", function* (next) {
    console.log("t2");
});
</code>
</pre>

<p>这么看Node.js是否能够胜任cpu密集型操作呢,答案当然是否定的,Node.js虽然是单线程,但是可以开启多个Node.js实例来充分利用多核的优势,另外Node.js还支持子进程,通过子进程来计算.</p>
<p>####for.js</p>
<pre>
<code class="javascript">
var calc = function() {
     for (var i = 0; i < 10000000000; i++) {
     }
}
process.on('message', function(m) {
  //接收主线程发来消息
     console.log("recv mesage");
     calc();
     process.send(1);
});
process.on('SIGHUP', function() {
          process.exit();//收到kill信息，进程退出
});
</code>
</pre>

<p>####main.js</p>
<pre>
<code class="javascript">
var fork = require('child_process').fork;
setTimeout(function () {
    var worker = fork("./for.js");
    worker.on("message", function(m) {
        //接收工作进程的结果
        console.log("world");
        worker.kill();
    });
    worker.send(1);
}, 200);

setTimeout(function () {
  console.log('hello');
}, 210);
</code>
</pre>

<p>上面这个程序就是利用进程间来通信,for.js是子进程执行的密集型计算.main.js可以继续调度其他程序.充分利用了cpu.</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre>
<code class="javascript">
setTimeout(function () {
    for (var i = 0; i < 10000000000; i++) {
        //CPU密集
    }
}, 200);

setTimeout(function () {
    console.log('210 ms...');
}, 210);
</code>
</pre>

<p>这个小例子很经典的解释了Node.js遇到密集型CPU的时候问题,这个程序分别在两个时间点触发,虽然在210ms得时候回调内得程序执行非常很快,但是在200ms得时候处理了一个CPU非常密集型的任务就导致整个线程阻塞了.<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="https://emacs.cn/tags/Node-js/"/>
    
      <category term="cpu密集型计算" scheme="https://emacs.cn/tags/cpu%E5%AF%86%E9%9B%86%E5%9E%8B%E8%AE%A1%E7%AE%97/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nohup和SIGHUP信号]]></title>
    <link href="https://emacs.cn/2014/12/nohup-sighup/"/>
    <id>https://emacs.cn/2014/12/nohup-sighup/</id>
    <published>2014-12-26T03:30:46.000Z</published>
    <updated>2017-07-27T11:06:24.000Z</updated>
    <content type="html"><![CDATA[<p>为什么这篇文章会提到nohup呢,主要还是最近在使用了一个叫maptail东西,它可以根据nginx的日志中IP来把IP和具体地址进行转换并显示在中国地图上.这样可以实时的查看接口的调用情况.</p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1enmxnoxfulj20kk0fr41o.jpg" alt="24pi_maptail"></p>
<p>这里不讨论maptail,主要说得是maptail启用方式: </p>
<pre>
<code class="bash">
tail -f nohup.out | maptail -h my.host.com -p 3000 > /dev/null & 
</code>
</pre>

<p>这条命令运行了一段时间后,进程就总是不响应了,但是进程还在.</p>
<p>不禁让我们对nohup和SIGHUP做了个实验.(自己写博可能有些跳跃,不明白可以直接回复:)</p>
<pre>
<code class="bash">
tail -f 1 &
</code>
</pre>

<p>这样放入后台后,通过进程树可以看到</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1enmy7tgiutj209q02sjrj.jpg" alt="tail进程树"><br>这个tail进程挂接在bash父进程上.</p>
<p>我们exit退出当前shell.再次进去看下:<br><img src="http://ww4.sinaimg.cn/large/744e593bgw1enmycasfnbj203f060wej.jpg" alt="tail进程树"><br>可见它被init进程来接管.</p>
<p>也就是这个进程运行正常,没什么问题.</p>
<p>那么nohup起了什么作用呢 ? </p>
<p>如果nohup起守护进程的作用,那么刚才这个进程也能正常运行于后台.</p>
<p>我们再用nohup来运行这个进程看看</p>
<pre>
<code class="bash">
nohup tail -f 2 &
</code>
</pre>

<p>按照上述操作,tail -f 2也同样跑在后台中.</p>
<p>nohup主要的作用是可以忽略SIGHUP信号,我们对上面两个进程分别进行发出kill -HUP 信号.</p>
<p>tail -f 2成功忽略了SIGHUP信号,而tail -f 1被成功杀死, 那么SIGHUP信号什么时候发出呢.</p>
<p>做了一些测试,关闭终端是不能发送SIGHUP给进程的.</p>
<p>当终端正常连接过程, 把笔记本合上, 过一段时间后, 发现tail -f 1被杀死了, 也就是说SIGHUP是终端连接断开时才发出的. 正常逻辑是: 当终端断开时,SIGHUP信号首先发给shell所在进程,而shell收到后,会向所有进程组发送SIGHUP信号,假设没有任何捕捉此信号，那么受到SIGHUP信号的进程就会关闭了, 而nohup守护的进程就不会.</p>
<p>当然如果遇到没有nohup进程已经运行,但是想把此进程离开当前进程组比如bash，可以借用distown这个命令.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为什么这篇文章会提到nohup呢,主要还是最近在使用了一个叫maptail东西,它可以根据nginx的日志中IP来把IP和具体地址进行转换并显示在中国地图上.这样可以实时的查看接口的调用情况.</p>
]]>
    
    </summary>
    
      <category term="nohup" scheme="https://emacs.cn/tags/nohup/"/>
    
      <category term="SIGHUP" scheme="https://emacs.cn/tags/SIGHUP/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js原子性操作MongoDB]]></title>
    <link href="https://emacs.cn/2014/12/howto-nodejs-atom-op-mongodb/"/>
    <id>https://emacs.cn/2014/12/howto-nodejs-atom-op-mongodb/</id>
    <published>2014-12-21T12:47:06.000Z</published>
    <updated>2017-07-27T11:05:34.000Z</updated>
    <content type="html"><![CDATA[<p>假设基础数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 0,
}
</code>
</pre>

<p>有时候为了充分利用多核,会同时开启多个node进程,但是若部分代码若涉及到操作mongodb就会有下面现象.<br>“理想情况下”,多个进程执行完后得数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 6000,
}
</code>
</pre>

<p>其实不然 !<br><a id="more"></a></p>
<p>我们看看获得结果是怎么样的.</p>
<pre>
<code class="javascript">
co(function* () {
    for (var i=0; i< 3000; i++) {
        var getTest = yield mongoCtest.findOne({"name":"cb"}, {"fields":{"_id":0}});
        getTest.data =  getTest.data+1;
        console.log(getTest);
        yield mongoCtest.update({"name":"good"}, {"$set":getTest});
    }
})();
</code>
</pre>

<p>上面的程序同时开两个,多个进程同时操作一个数据.<br>可能结果会是:<br><img src="http://ww1.sinaimg.cn/large/744e593bgw1enhm3w6525j20wo0n6459.jpg" alt="多进程操作Mongo"></p>
<p>我们知道Mongo是不支持事务的,如果你能容忍上面的弱一致性,那么没问题.但是如果你不能容忍，要么考虑MySql关系型数据库,要么自己解决事务问题.</p>
<p>下面我来说下基于Mongo怎么解决事务问题.<br>我们需要对每个数据加一个version来控制.直接上代码:</p>
<pre>
<code class="javascript">
co(function* () {
    for (var i=0; i< 3000; i++) {
        while (1) {
            var getTest = yield mongoCtest.findOne({"name":"cb"}, {"fields":{"_id":0}});
            getTest.data =  getTest.data+1;
            var originalVer = getTest.ver;
            getTest.ver = getTest.ver+1;
            console.log(getTest);
            var ret = yield mongoCtest.update({"name":"cb", "ver":originalVer}, {"$set":getTest});
            if (ret)  break;
        }
    }
})();
</code>
</pre>

<p>下面就是我们想要的结果:)</p>
<p><img src="http://ww1.sinaimg.cn/large/744e593bgw1enhm5tgq6qj20xt0njqbo.jpg" alt="原子性控制"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设基础数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 0,
}
</code>
</pre>

<p>有时候为了充分利用多核,会同时开启多个node进程,但是若部分代码若涉及到操作mongodb就会有下面现象.<br>“理想情况下”,多个进程执行完后得数据为:</p>
<pre>
<code class="javascript">
{
    "name" : "cb",
    "data" : 6000,
}
</code>
</pre>

<p>其实不然 !<br>]]>
    
    </summary>
    
      <category term="Node.js" scheme="https://emacs.cn/tags/Node-js/"/>
    
      <category term="MongoDB" scheme="https://emacs.cn/tags/MongoDB/"/>
    
      <category term="原子性" scheme="https://emacs.cn/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由 C 中字符串比较引入的问题]]></title>
    <link href="https://emacs.cn/2012/07/c-string-question/"/>
    <id>https://emacs.cn/2012/07/c-string-question/</id>
    <published>2012-07-19T14:27:45.000Z</published>
    <updated>2017-07-27T11:05:21.000Z</updated>
    <content type="html"><![CDATA[<p>一个同事在Project中写下如下错误代码(为了说明问题, 代码已经简写)</p>
<pre>
<code class="C">
void function(const char* _str) {
    if (_str == "OK") {

    }
}
</code>
</pre>

<p>这段代码 错就错在把char*(从堆里分配的)字符串直接 常量字符串进行比较.<br>而这位同事不解的拿出下面这个例子对我发出这样的疑问:为什么会这样?</p>
<a id="more"></a>
<pre>
<code class="C">
#include < stdio.h>
int main(int argc, const char** argv)
{
    char str_1[6] = "Crazy1";
    char* str_2 = "Crazy2";
    if (str_1 == "Crazy1") {
        printf("%s\n", "字符数组OK");
    }
    if (str_2 == "Crazy2") {
        printf("%s\n", "字符串常量OK");
    }

    return 0;
}
</code>
</pre>

<p>输出结果: 字符串常量OK</p>
<p>大部份人认为只有C++的String类才能执行等于比较符号操作, 而C中需要使用strcmp来进行”字符串”比较, 为什么这段程序告诉我们字符串常量是可以的, 而字符数组是不可以的. 这里其实主要是字符数组和字符串常量的区别,至于它们本质区别就不多说了, 比如一个存储在静态存储区, 一个在栈上分配空间…</p>
<p>这里主要要知道 str_2是指针, 指向”Crazy2″这个字符串常量的内存首地址,  而str_1是在栈里分配的字符数组”Crazy1″的首地址.</p>
<p>我们更深一步来解释这个问题:</p>
<p>咱们反汇编这段代码:</p>
<pre>
<code class="C">
.section .rodata
.LC0:
.string "Crazy2"
.LC1:
.string "OK"
.text
.globl main
.type main, @function
main:
pushl %ebp
movl %esp, %ebp
andl $-16, %esp
subl $32, %esp
movl $2053206595, 22(%esp)
movw $12665, 26(%esp)
movl $.LC0, 28(%esp)
cmpl $.LC0, 28(%esp)
jne .L2
movl $.LC1, (%esp)
call puts
.L2:
movl $0, %eax
leave
ret
.size main, .-main
.ident "GCC: (GNU) 4.5.1 20100924 (Red Hat 4.5.1-4)"
.section .note.GNU-stack,"",@progbits
</code>
</pre>

<p>咱们根据这段汇编代码可以看出 字符串常量是在编译时就确定的, 而字符数组是在运行时确定的.</p>
<pre>
<code class="C">
movl $.LC0, 28(%esp)
cmpl $.LC0, 28(%esp)
</code>
</pre>

<p>这2句可以直接看出 字符串常量的比较是怎么运算的.</p>
<p>而字符数组为什么不行呢? 很显然 因为他们不属于同一个内存空间.</p>
<blockquote>
<p>建议: C字符串比较都使用strcmp</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个同事在Project中写下如下错误代码(为了说明问题, 代码已经简写)</p>
<pre>
<code class="C">
void function(const char* _str) {
    if (_str == "OK") {

    }
}
</code>
</pre>

<p>这段代码 错就错在把char*(从堆里分配的)字符串直接 常量字符串进行比较.<br>而这位同事不解的拿出下面这个例子对我发出这样的疑问:为什么会这样?</p>
]]>
    
    </summary>
    
      <category term="C" scheme="https://emacs.cn/tags/C/"/>
    
      <category term="字符串" scheme="https://emacs.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MONGODB的BASIC INDEXES 和 COMPOUND INDEXES 研究]]></title>
    <link href="https://emacs.cn/2012/07/mongodb-basic-indexes-compound-indexes/"/>
    <id>https://emacs.cn/2012/07/mongodb-basic-indexes-compound-indexes/</id>
    <published>2012-07-11T17:18:41.000Z</published>
    <updated>2017-07-27T11:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>前几天看到一个关于 MongoDB 深入索引的PPT</p>
<p><a href="http://www.slideshare.net/mongodb/mongodb-indexing-the-details" target="_blank" rel="external">MongoDB Indexing: The Details</a></p>
<p>仔细的从头看到尾, 里面有个关于Compound Indexes的Range and Equality的讲解,在ppt第129页,重新回顾下这个例子.向一个collection中插入 9 条数据,像下面这样:</p>
<pre>
<code class="javascript">
> db.good.find()
{ "_id" : ObjectId("4e8d629d8ad8bdf2ed6c1990"), "x" : 1, "y" : "b" }
{ "_id" : ObjectId("4e8d62a38ad8bdf2ed6c1991"), "x" : 3, "y" : "d" }
{ "_id" : ObjectId("4e8d62ad8ad8bdf2ed6c1992"), "x" : 4, "y" : "g" }
{ "_id" : ObjectId("4e8d62b28ad8bdf2ed6c1993"), "x" : 5, "y" : "c" }
{ "_id" : ObjectId("4e8d62ba8ad8bdf2ed6c1994"), "x" : 6, "y" : "a" }
{ "_id" : ObjectId("4e8d62c18ad8bdf2ed6c1995"), "x" : 7, "y" : "e" }
{ "_id" : ObjectId("4e8d62ce8ad8bdf2ed6c1996"), "x" : 8, "y" : "c" }
{ "_id" : ObjectId("4e8d62d38ad8bdf2ed6c1997"), "x" : 9, "y" : "f" }
{ "_id" : ObjectId("4e8d719a6cee6416a5a75a43"), "x" : 5, "y" : "d" }
</code>
</pre>
<a id="more"></a>

然后给x 和 y进行联合索引
<pre>
<code class="javascript">
db.good.ensureIndex({x:1,y:1})
</code>
</pre>

<p>我们来进行这样的查找</p>
<pre>
<code class="javascript">
> db.good.find({x:{$gte:4}, y:’c’}).explain()
{
    "cursor" : "BtreeCursor x_1_y_1",
        "nscanned" : 7,
        "nscannedObjects" : 2,
        "n" : 2,
        "millis" : 0,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "isMultiKey" : false,
        "indexOnly" : false,
        "indexBounds" : {
            "x" : [
                [
                    4,
                    1.7976931348623157e+308
                ]
            ],
            "y" : [
                [
                    "c",
                    "c"
                ]
            ]
        }
}
</code>
</pre>

<p>可以看出 nscanned 非常高! 而 n只有 2 .官网上有这样一句话:</p>
<blockquote>
<p>If nscanned is much higher than nreturned, the database is scanning many objects to find the target objects. Consider creating an index to improve this.</p>
</blockquote>
<p>这里nscanned可以认为是扫描的记录数.n为返回的记录数</p>
<p>让我们配合PPT看下 nscanned:7是怎么来的:</p>
<p><img src="http://ww3.sinaimg.cn/large/744e593bgw1end6qzl43vj20fy09t0ta.jpg" alt="BTree"></p>
<p>这是MongoDB的B-tree索引树,因为x&gt;=4 &amp;&amp; y=’c’,所以先选择左枝搜索,左枝搜索了4/g 和 5/c ,(5/c符合条件),然后搜索 右枝 搜索了 7/e, 6/a ,8/c, 9/f ,(8/c符合条件). 任何 符合的 x都要被check一下.</p>
<p>###延伸</p>
<p>看了PPT后到此结尾了, 真遇到这种情况,效率可不乐观,于是稍微思考了下, y 在 这颗树中只有两个节点含有,也就是说 既然是 ‘与’  那就只要先把 y 筛选出来 ,搜索次数就大大减半了 .</p>
<p>我们在 y 上再进行Basic Indexes 的建立.</p>
<pre>
<code class="javascript">
db.good.ensureIndex({y:1})
</code>
</pre>

<p>这样如果搜索时会先 搜索 y  ,也就只有2次搜索了.看下实际情况:</p>
<pre>
<code class="javascript">
> db.good.find({x:{$gte:4}, y:’c’}).explain()
{
    "cursor" : "BtreeCursor y_1",
        "nscanned" : 2,
        "nscannedObjects" : 2,
        "n" : 2,
        "millis" : 0,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "isMultiKey" : false,
        "indexOnly" : false,
        "indexBounds" : {
            "y" : [
                [
                    "c",
                    "c"
                ]
            ]
        }
}
</code>
</pre>

<p>正如预料的一样. 直接走 基本索引了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看到一个关于 MongoDB 深入索引的PPT</p>
<p><a href="http://www.slideshare.net/mongodb/mongodb-indexing-the-details" target="_blank" rel="external">MongoDB Indexing: The Details</a></p>
<p>仔细的从头看到尾, 里面有个关于Compound Indexes的Range and Equality的讲解,在ppt第129页,重新回顾下这个例子.向一个collection中插入 9 条数据,像下面这样:</p>
<pre>
<code class="javascript">
> db.good.find()
{ "_id" : ObjectId("4e8d629d8ad8bdf2ed6c1990"), "x" : 1, "y" : "b" }
{ "_id" : ObjectId("4e8d62a38ad8bdf2ed6c1991"), "x" : 3, "y" : "d" }
{ "_id" : ObjectId("4e8d62ad8ad8bdf2ed6c1992"), "x" : 4, "y" : "g" }
{ "_id" : ObjectId("4e8d62b28ad8bdf2ed6c1993"), "x" : 5, "y" : "c" }
{ "_id" : ObjectId("4e8d62ba8ad8bdf2ed6c1994"), "x" : 6, "y" : "a" }
{ "_id" : ObjectId("4e8d62c18ad8bdf2ed6c1995"), "x" : 7, "y" : "e" }
{ "_id" : ObjectId("4e8d62ce8ad8bdf2ed6c1996"), "x" : 8, "y" : "c" }
{ "_id" : ObjectId("4e8d62d38ad8bdf2ed6c1997"), "x" : 9, "y" : "f" }
{ "_id" : ObjectId("4e8d719a6cee6416a5a75a43"), "x" : 5, "y" : "d" }
</code>
</pre>
]]>
    
    </summary>
    
      <category term="MongoDB" scheme="https://emacs.cn/tags/MongoDB/"/>
    
      <category term="索引" scheme="https://emacs.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="技术" scheme="https://emacs.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
